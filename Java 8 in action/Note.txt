1. 几种内置的函数接口

-Predicate
java.util.function.Predicate<T>接口定义了一个名叫test的抽象方法，它接受泛型
T对象，并返回一个boolean。这恰恰和你先前创建的一样，现在就可以直接使用了。在你需要
表示一个涉及类型T的布尔表达式时，就可以使用这个接口。比如，你可以定义一个接受String
对象的Lambda表达式，如下所示。
代码清单3-2 使用Predicate
@FunctionalInterface
public interface Predicate<T>{
boolean test(T t);
}
public static <T> List<T> filter(List<T> list, Predicate<T> p) {
List<T> results = new ArrayList<>();
	for(T s: list){
		if(p.test(s)){
			results.add(s);
		}
	}
	return results;
}

Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);

Consumer
java.util.function.Consumer<T>定义了一个名叫accept的抽象方法，它接受泛型T
的对象，没有返回（void）。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用
这个接口。比如，你可以用它来创建一个forEach方法，接受一个Integers的列表，并对其中
每个元素执行操作。在下面的代码中，你就可以使用这个forEach方法，并配合Lambda来打印
列表中的所有元素。
代码清单3-3 使用Consumer
@FunctionalInterface
public interface Consumer<T>{
void accept(T t);
}

public static <T> void forEach(List<T> list, Consumer<T> c){
	for(T i: list){
		c.accept(i);
	}
}

forEach(Arrays.asList(1,2,3,4,5), (Integer i) -> System.out.println(i));

Function
java.util.function.Function<T, R>接口定义了一个叫作apply的方法，它接受一个
泛型T的对象，并返回一个泛型R的对象。如果你需要定义一个Lambda，将输入对象的信息映射
到输出，就可以使用这个接口（比如提取苹果的重量，或把字符串映射为它的长度）。在下面的
代码中，我们向你展示如何利用它来创建一个map方法，以将一个String列表映射到包含每个
String长度的Integer列表。

代码清单3-4 使用Function
@FunctionalInterface
public interface Function<T, R>{
	R apply(T t);
}

public static <T, R> List<R> map(List<T> list,Function<T, R> f) {
	List<R> result = new ArrayList<>();
	for(T s: list){
		result.add(f.apply(s));
	}
	return result;
}

// [7, 2, 6]
List<Integer> l = map(Arrays.asList("lambdas","in","action"), (String s) -> s.length());

Functional interface	Function descriptor		Primitive specializations

Predicate<T> 		T -> boolean 			IntPredicate, LongPredicate, DoublePredicate
Consumer<T> 		T -> void 			IntConsumer, LongConsumer, DoubleConsumer
Function<T, R> 		T -> R 				IntFunction<R>, IntToDoubleFunction, IntToLongFunction, LongFunction<R>, LongToDoubleFunction, LongToIntFunction, DoubleFunction<R>, ToIntFunction<T>, ToDoubleFunction<T>, ToLongFunction<T>
Supplier<T> 		() -> T 			BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier
UnaryOperator<T> 	T -> T 				IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator
BinaryOperator<T> 	(T, T) -> T 			IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator
BiPredicate<L, R> 	(L, R) ->boolean
BiConsumer<T, U> 	(T, U) -> void 			ObjIntConsumer<T>, ObjLongConsumer<T>,ObjDoubleConsumer<T>
BiFunction<T, U, R> 	(T, U) -> R 			ToIntBiFunction<T, U>, ToLongBiFunction<T, U>, ToDoubleBiFunction<T, U>

为了避免装箱操作, 对Predicate<T>和Function<T, R>等通用函数式接口的原始类型特化：IntPredicate、IntToLongFunction等。
如果是原始类型，就用上卖弄特化的接口，如果是对象类型，就直接用对应的functional接口。

2. Lambda类型推断
你还可以进一步简化你的代码。Java编译器会从上下文（目标类型）推断出用什么函数式接
口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通
过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可
以在Lambda语法中省去标注参数类型。换句话说，Java编译器会像下面这样推断Lambda的参数
类型：①
List<Apple> greenApples =
filter(inventory, a -> "green".equals(a.getColor()));
Lambda表达式有多个参数，代码可读性的好处就更为明显。例如，你可以这样来创建一个
Comparator对象：
Comparator<Apple> c =
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
Comparator<Apple> c =
(a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
请注意，有时候显式写出类型更易读，有时候去掉它们更易读。没有什么法则说哪种更好；
对于如何让代码更易读，程序员必须做出自己的选择。

3. Lambda使用局部变量
Lambda可以没有限
制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，
或事实上是final

4. Lambda方法引用
先前：
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
之后（使用方法引用和java.util.Comparator.comparing）：
inventory.sort(comparing(Apple::getWeight));

方法引用主要有三类。
(1) 指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt）。
(String s) -> Integer.parseInt(s)可以写作Integer::parseInt
(2) 指向任意类型实例方法的方法引用（ 例如String 的length 方法， 写作String::length）。
(String s) -> s.toUppeCase()可以写作String::toUpperCase。
(3) 指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensive-
Transaction::getValue）。
expr是一个已经存在的外部对象。
(String s) -> expr.instanceMethod(s) 可以写成expr::instanceMethod

第1种情况还可用于构造函数
对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用, ClassName::new。它的功能与指向静态方法的引用类似。

例如，假设有一个构造函数没有参数。它适合Supplier的签名() -> Apple。你可以这样做：

Supplier<Apple> c1 = () -> new Apple();
Apple a1 = c1.get();
这就等价于：
Supplier<Apple> c1 = Apple::new;
Apple a1 = c1.get();

如果你的构造函数的签名是Apple(Integer weight)，那么它就适合Function接口的签
名，于是你可以这样写：
Function<Integer, Apple> c2 = (weight) -> new Apple(weight);
Apple a2 = c2.apply(110);
这就等价于：
Function<Integer, Apple> c2 = Apple::new;
Apple a2 = c2.apply(110);

如果你有一个具有两个参数的构造函数Apple(String color, Integer weight)，那么
它就适合BiFunction接口的签名，于是你可以这样写：
BiFunction<String, Integer, Apple> c3 = (color, weight) -> new Apple(color, weight);
Apple c3 = c3.apply("green", 110);

这就等价于：

BiFunction<String, Integer, Apple> c3 = Apple::new;
Apple c3 = c3.apply("green", 110);

你已经看到了如何将有零个、一个、两个参数的构造函数转变为构造函数引用。那要怎么
样才能对具有三个参数的构造函数，比如Color(int, int, int)，使用构造函数引用呢？
答案：你看，构造函数引用的语法是ClassName::new，那么在这个例子里面就是
Color::new。但是你需要与构造函数引用的签名匹配的函数式接口。但是语言本身并没有提
供这样的函数式接口，你可以自己创建一个：
public interface TriFunction<T, U, V, R>{
	R apply(T t, U u, V v);
}
现在你可以像下面这样使用构造函数引用了：
TriFunction<Integer, Integer, Integer, Color> colorFactory = Color::new;


第3种情况的另一个例子:
List<String> str = Arrays.asList("a","b","A","B");
str.sort((s1, s2) -> s1.compareToIgnoreCase(s2));
可以写成
str.sort(String::compareToIgnoreCase)

5 复合Lambda

谓词接口包括三个方法：negate、and和or，让你可以重用已有的Predicate来创建更复
杂的谓词。比如，你可以使用negate方法来返回一个Predicate的非，比如苹果不是红的：
Predicate<Apple> notRedApple = redApple.negate();

你可能想要把两个Lambda用and方法组合起来，比如一个苹果既是红色又比较重：
Predicate<Apple> redAndHeavyApple = redApple.and(a -> a.getWeight() > 150);
你可以进一步组合谓词，表达要么是重（150克以上）的红苹果，要么是绿苹果：
Predicate<Apple> redAndHeavyAppleOrGreen = redApple.and(a -> a.getWeight() > 150)
						   .or(a -> "green".equals(a.getColor()));


你还可以把Function接口所代表的Lambda表达式复合起来。Function接口为此配
了andThen和compose两个默认方法，它们都会返回Function的一个实例。
andThen方法会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数。
比如，假设有一个函数f给数字加1 (x -> x + 1)，另一个函数g给数字乘2，你可以将它们组
合成一个函数h，先给数字加1，再给结果乘2：
Function<Integer, Integer> f = x -> x + 1;
Function<Integer, Integer> g = x -> x * 2;
Function<Integer, Integer> h = f.andThen(g);
int result = h.apply(1);            ===>相当于 g(f(1)) 返回4
你也可以类似地使用compose方法，先把给定的函数用作compose的参数里面给的那个函
数，然后再把函数本身用于结果。比如在上一个例子里用compose的话，它将意味着f(g(x))，
而andThen则意味着g(f(x))：
Function<Integer, Integer> f = x -> x + 1;
Function<Integer, Integer> g = x -> x * 2;
Function<Integer, Integer> h = f.compose(g);
int result = h.apply(1);        ===>相当于f(g(1)) 返回3

5. stream 筛选
- filter
Streams接口支持filter方法（你现在应该很熟悉了）。该操作会接受一个谓词（一个返回
boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。
List<Dish> vegetarianMenu = menu.stream().filter(Dish::isVegetarian).collect(toList());
- distinct
流还支持一个叫作distinct的方法，它会返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流
List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
numbers.stream().filter(i -> i % 2 == 0).distinct().forEach(System.out::println);
- limit
流支持limit(n)方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递
给limit。如果流是有序的，则最多会返回前n个元素。
List<Dish> dishes = menu.stream().filter(d -> d.getCalories() > 300).limit(3).collect(toList());
-skip
流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一
个空流。请注意，limit(n)和skip(n)是互补的
List<Dish> dishes = menu.stream().filter(d -> d.getCalories() > 300).skip(2).collect(toList());

6. stream 映射
-map
流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映
射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一
个新版本”而不是去“修改”）
List<String> dishNames = menu.stream().map(Dish::getName).collect(toList());
-flatmap
flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。
List<String> uniqueCharacters =words.stream().map(w -> w.split("")).flatMap(Arrays::stream).distinct().collect(Collectors.toList());

List<Integer> numbers1 = Arrays.asList(1, 2, 3);
List<Integer> numbers2 = Arrays.asList(3, 4);
List<int[]> pairs =numbers1.stream().flatMap(i -> numbers2.stream().map(j -> new int[]{i, j})).collect(toList());

7. stream 查找
- 过allMatch、anyMatch、noneMatch、findFirst和findAny (终端操作）
if(menu.stream().anyMatch(Dish::isVegetarian)){
	System.out.println("The menu is (somewhat) vegetarian friendly!!");
}

Optional<Dish> dish =menu.stream().filter(Dish::isVegetarian).findAny();
Optional<T>类（java.util.Optional）是一个容器类，代表一个值存在或不存在。在上面的代码中，findAny可能什么元素都没找到。

Optional里面几种可以迫使你显式地检查值是否存在或处理值不存在的情形的方法也不错。
 isPresent()将在Optional包含值的时候返回true, 否则返回false。
 ifPresent(Consumer<T> block)会在值存在的时候执行给定的代码块。我们在第3章
介绍了Consumer函数式接口；它让你传递一个接收T类型参数，并返回void的Lambda
表达式。
 T get()会在值存在时返回值，否则抛出一个NoSuchElement异常。
 T orElse(T other)会在值存在时返回值，否则返回一个默认值。

8. stream 规约
- reduce
求和
int sum = numbers.stream().reduce(0, (a, b) -> a + b);

无初始值
reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：
Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));
为什么它返回一个Optional<Integer>呢？考虑流中没有任何元素的情况。reduce操作无
法返回其和，因为它没有初始值。这就是为什么结果被包裹在一个Optional对象里，以表明和
可能不存在

还有一种适用于并行操作的reduce
<U> U reduce(U identity,
                 BiFunction<U, ? super T, U> accumulator,
                 BinaryOperator<U> combiner)

分析下它的三个参数：

    identity: 一个初始化的值；这个初始化的值其类型是泛型U，与Reduce方法返回的类型一致；注意此时Stream中元素的类型是T，与U可以不一样也可以一样，这样的话操作空间就大了；不管Stream中存储的元素是什么类型，U都可以是任何类型，如U可以是一些基本数据类型的包装类型Integer、Long等；或者是String，又或者是一些集合类型ArrayList等；后面会说到这些用法。
    accumulator: 其类型是BiFunction，输入是U与T两个类型的数据，而返回的是U类型；也就是说返回的类型与输入的第一个参数类型是一样的，而输入的第二个参数类型与Stream中元素类型是一样的。
    combiner: 其类型是BinaryOperator，支持的是对U类型的对象进行操作；

第三个参数combiner主要是使用在并行计算的场景下；如果Stream是非并行时，第三个参数实际上是不生效的。

第三个参数cobiner就是用来将各个线程的结果合并的时候使用。

求最大值
Optional<Integer> max = numbers.stream().reduce(Integer::max);

9. 原始类型流特化
Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和
LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。
1. 映射到数值流
int calories = menu.stream().mapToInt(Dish::getCalories).sum();
这里，mapToInt会从每道菜中提取热量（用一个Integer表示），并返回一个IntStream（而不是一个Stream<Integer>）。
2. 转换回对象流
IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
Stream<Integer> stream = intStream.boxed();
3. 默认值OptionalInt
求和的那个例子很容易，因为它有一个默认值：0。但是，如果你要计算IntStream中的最
大元素，就得换个法子了，因为0是错误的结果。如何区分没有元素的流和最大值真的是0的流呢？
前面我们介绍了Optional类，这是一个可以表示值存在或不存在的容器。Optional可以用
Integer、String等参考类型来参数化。对于三种原始流特化，也分别有一个Optional原始类
型特化版本：OptionalInt、OptionalDouble和OptionalLong。
例如，要找到IntStream中的最大元素，可以调用max方法，它会返回一个OptionalInt：
OptionalInt maxCalories = menu.stream()
.mapToInt(Dish::getCalories)
.max();
现在，如果没有最大值的话，你就可以显式处理OptionalInt去定义一个默认值了：
int max = maxCalories.orElse(1);


数值范围
Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围：
range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但
range是不包含结束值的，而rangeClosed则包含结束值。让我们来看一个例子：

IntStream evenNumbers = IntStream.rangeClosed(1, 100).filter(n -> n % 2 == 0);
System.out.println(evenNumbers.count());

10 构建流
由值创建流
Stream<String> stream = Stream.of("Java 8 ", "Lambdas ", "In ", "Action");
stream.map(String::toUpperCase).forEach(System.out::println);
你可以使用empty得到一个空流，如下所示：
Stream<String> emptyStream = Stream.empty();

由数组创建流
你可以使用静态方法Arrays.stream从数组创建一个流。它接受一个数组作为参数。例如，
你可以将一个原始类型int的数组转换成一个IntStream，如下所示：
int[] numbers = {2, 3, 5, 7, 11, 13};
int sum = Arrays.stream(numbers).sum();

由文件生成流
long uniqueWords = 0;
try(Stream<String> lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset())){
	uniqueWords = lines.flatMap(line -> Arrays.stream(line.split(" "))).distinct().count();
}
catch(IOException e){
}

由函数生成流：创建无限流  (应该使用limit(n)来对这种流加以限制)

-迭代
Stream.iterate(0, n -> n + 2).limit(10).forEach(System.out::println);
iterate方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的Lambda（UnaryOperator<t>类型）

-生成
与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次
对每个新生成的值应用函数的。它接受一个Supplier<T>类型的Lambda提供新的值。我们先来
看一个简单的用法：
Stream.generate(Math::random).limit(5).forEach(System.out::println);

11 stream收集器
Stream.collect(Collector<? super T,A,R> collector)
Performs a mutable reduction operation on the elements of this stream using a Collector.

Interface Collector<T,A,R>

    Type Parameters:
        T - the type of input elements to the reduction operation
        A - the mutable accumulation type of the reduction operation (often hidden as an implementation detail)
        R - the result type of the reduction operation 

A Collector is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result. They are:

    creation of a new result container (supplier())
    incorporating a new data element into a result container (accumulator())
    combining two result containers into one (combiner())
    performing an optional final transform on the container (finisher())

     A a1 = supplier.get();
     accumulator.accept(a1, t1);
     accumulator.accept(a1, t2);
     R r1 = finisher.apply(a1);  // result without splitting

     A a2 = supplier.get();
     accumulator.accept(a2, t1);
     A a3 = supplier.get();
     accumulator.accept(a3, t2);
     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting

所以一个stream调用了collect方法后，就会展昭下面的逻辑依次对流里面里面的元素利用指定的collector实例进行如下的循环处理
-首先调用collector的supplier.get()方法获得一个中间结果的容器
-依次将流里面的元素放进去
-调用collector的apply()方法对里面元素进行处理然后返回collector指定的结果类型

Collectors.*里面由很多collector的具体实现。

-计数
long howManyDishes = menu.stream().collect(Collectors.counting());
-求最大最小值
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);
Optional<Dish> mostCalorieDish = menu.stream().collect(Collectors.maxBy(dishCaloriesComparator));
-汇总 （Collectors.summingLong和Collectors.summingDouble方法的作用完全一样，可以用于求和字段为long或double的情况）
int totalCalories = menu.stream().collect(Collectors.summingInt(Dish::getCalories));  ==>对流里面的每个元素调用方法getCalories()获取一个int然后将他们加再一起，最后将和返回.

汇总不仅仅是求和；还有Collectors.averagingInt，连同对应的averagingLong和averagingDouble可以计算数值的平均数：
double avgCalories =menu.stream().collect(Collectors.averagingInt(Dish::getCalories));

通过一次summarizing操作你可以就数出菜单中元素的个数，并得到菜肴热量总和、平均值、最大值和最小值：
IntSummaryStatistics menuStatistics =menu.stream().collect(Collectors.summarizingInt(Dish::getCalories));

这个收集器会把所有这些信息收集到一个叫作IntSummaryStatistics的类里，它提供了方便的取值（getter）方法来访问结果。打印menuStatisticobject会得到以下输出：
IntSummaryStatistics{count=9, sum=4300, min=120,average=477.777778, max=800}

同样，相应的summarizingLong和summarizingDouble工厂方法有相关的LongSummaryStatistics和DoubleSummaryStatistics类型，适用于收集的属性是原始类型long或double的情况

- 连接字符串
String shortMenu = menu.stream().map(Dish::getName).collect(Collectors.joining());

-广义的归约汇总
int totalCalories = menu.stream().collect(Collectors.reducing(0, Dish::getCalories, (i, j) -> i + j));

它需要三个参数。
 第一个参数是归约操作的起始值，也是流中没有元素时的返回值，所以很显然对于数值
和而言0是一个合适的值。
 第二个参数就是你在6.2.2节中使用的函数，将菜肴转换成一个表示其所含热量的int。
 第三个参数是一个BinaryOperator，将两个项目累积成一个同类型的值。这里它就是
对两个int求和。
同样，你可以使用下面这样单参数形式的reducing来找到热量最高的菜，如下所示：
Optional<Dish> mostCalorieDish =menu.stream().collect(reducing((d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2));
你可以把单参数reducing工厂方法创建的收集器看作三参数方法的特殊情况，它把流中的
第一个项目作为起点，把恒等函数（即一个函数仅仅是返回其输入参数）作为一个转换函数。这
也意味着，要是把单参数reducing收集器传递给空流的collect方法，收集器就没有起点；正
如我们在6.2.1节中所解释的，它将因此而返回一个Optional<Dish>对象。

收集器的选择： 根据情况选择最佳解决方案
我们的建议是，尽可能为手头的问题探索不同的解决方案，但在通用的方案里面，始终选择
最专门化的一个。无论是从可读性还是性能上看，这一般都是最好的决定。例如，要计菜单的总
热量，我们更倾向于最后一个解决方案（使用IntStream），因为它最简明，也很可能最易读。
同时，它也是性能最好的一个，因为IntStream可以让我们避免自动拆箱操作.
int totalCalories = menu.stream().mapToInt(Dish::getCalories).sum();    ==>mapToInt返回一个IntStream

12 stream 分组
Map<Dish.Type, List<Dish>> dishesByType = menu.stream().collect(groupingBy(Dish::getType));
其结果是下面的Map：
{FISH=[prawns, salmon], OTHER=[french fries, rice, season fruit, pizza], MEAT=[pork, beef, chicken]}
这里，你给groupingBy方法传递了一个Function（以方法引用的形式），它提取了流中每
一道Dish的Dish.Type。我们把这个Function叫作分类函数，因为它用来把流中的元素分成不
同的组。如图6-4所示，分组操作的结果是一个Map，把分组函数返回的值作为映射的键，把流中
所有具有这个分类值的项目的列表作为对应的映射值。

- 一级分组
groupingBy(Function<? super T,? extends K> classifier)
Returns a Collector implementing a "group by" operation on input elements of type T, grouping elements according to a classification function, and returning the results in a Map.

public enum CaloricLevel { DIET, NORMAL, FAT }
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = 
	menu.stream().collect(
			groupingBy(dish -> {
					if (dish.getCalories() <= 400) return CaloricLevel.DIET;
					else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
					else return CaloricLevel.FAT;
					} ));


- 二级分组
groupingBy(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream)
Returns a Collector implementing a cascaded "group by" operation on input elements of type T, grouping elements according to a classification function, 
and then performing a reduction operation on the values associated with a given key using the specified downstream Collector.

Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel =
	menu.stream().collect(
			groupingBy(Dish::getType,
				   groupingBy(dish -> {
						if (dish.getCalories() <= 400) return CaloricLevel.DIET;
						else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
						else return CaloricLevel.FAT;
						} )
				  )
			      );

这个二级分组的结果就是像下面这样的两级Map：
{MEAT={DIET=[chicken], NORMAL=[beef], FAT=[pork]},
FISH={DIET=[prawns], NORMAL=[salmon]},
OTHER={DIET=[rice, seasonal fruit], NORMAL=[french fries, pizza]}}

- 按子组收集数据
Map<Dish.Type, Long> typesCount = menu.stream().collect(groupingBy(Dish::getType, counting()));
其结果是下面的Map：
{MEAT=3, FISH=2, OTHER=4}

Map<Dish.Type, Optional<Dish>> mostCaloricByType =menu.stream().collect(groupingBy(Dish::getType,maxBy(comparingInt(Dish::getCalories))));
这个分组的结果显然是一个map，以Dish的类型作为键，以包装了该类型中热量最高的Dish的Optional<Dish>作为值：
{FISH=Optional[salmon], OTHER=Optional[pizza], MEAT=Optional[pork]}

- 把收集器的结果转换为另一种类型
Map<Dish.Type, Dish> mostCaloricByType =
	menu.stream()
		.collect(groupingBy(Dish::getType,
				    collectingAndThen(
					maxBy(comparingInt(Dish::getCalories)),
					Optional::get)));
其结果是下面的Map：
{FISH=salmon, OTHER=pizza, MEAT=pork}

- 与groupingBy联合使用的其他收集器的例子
Map<Dish.Type, Set<CaloricLevel>> caloricLevelsByType =
	menu.stream().collect(
		groupingBy(Dish::getType, 
			   mapping(
				dish -> { if (dish.getCalories() <= 400) return CaloricLevel.DIET;
					  else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
					  else return CaloricLevel.FAT; },
				toSet() )));

结果：
{OTHER=[DIET, NORMAL], MEAT=[DIET, NORMAL, FAT], FISH=[DIET, NORMAL]}

如果想明确指定返回的map类型，可以用这个API
groupingBy(Function<? super T,? extends K> classifier, Supplier<M> mapFactory, Collector<? super T,A,D> downstream)
Returns a Collector implementing a cascaded "group by" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector.
具体返回的map类型由mapFactory指定
Map<City, Set<String>> namesByCity
         = people.stream().collect(groupingBy(Person::getCity, TreeMap::new,
                                              mapping(Person::getLastName, toSet())));

13 stream分区
分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函
数。分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它最多可以
分为两组——true是一组，false是一组。例如，如果你是素食者或是请了一位素食的朋友来共
进晚餐，可能会想要把菜单按照素食和非素食分开：
Map<Boolean, List<Dish>> partitionedMenu = menu.stream().collect(partitioningBy(Dish::isVegetarian));
这会返回下面的Map：
{false=[pork, beef, chicken, prawns, salmon], true=[french fries, rice, season fruit, pizza]}
那么通过Map中键为true的值，就可以找出所有的素食菜肴了：
List<Dish> vegetarianDishes = partitionedMenu.get(true);

，partitioningBy工厂方法有一个重载版本，可以像下面这样传递第二个收集器：
Map<Boolean, Map<Dish.Type, List<Dish>>> vegetarianDishesByType =
	menu.stream().collect(
			partitioningBy(Dish::isVegetarian,
				       groupingBy(Dish::getType)));
这将产生一个二级Map：
{false={FISH=[prawns, salmon], MEAT=[pork, beef, chicken]},true={OTHER=[french fries, rice, season fruit, pizza]}}

再举一个例子，你可以重用前面的代码来找到素食和非素
食中热量最高的菜：
Map<Boolean, Dish> mostCaloricPartitionedByVegetarian =
	menu.stream().collect(
			partitioningBy(Dish::isVegetarian,
				       collectingAndThen(
						maxBy(comparingInt(Dish::getCalories)),
						      Optional::get)));
这将产生以下结果：
{false=pork, true=pizza}

14 创建自己的collector
import java.util.*;
import java.util.function.*;
import java.util.stream.Collector;
import static java.util.stream.Collector.Characteristics.*;
public class ToListCollector<T> implements Collector<T, List<T>, List<T>> {
@Override
public Supplier<List<T>> supplier() {
	return ArrayList::new;
}
@Override
public BiConsumer<List<T>, T> accumulator() {
	return List::add;
}
@Override
public Function<List<T>, List<T>> finisher() {
	return Function.indentity();
}
@Override
public BinaryOperator<List<T>> combiner() {
	return (list1, list2) -> {
			list1.addAll(list2);
			return list1;
		};
}
@Override
public Set<Characteristics> characteristics() {
	return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, CONCURRENT));

1. 建立新的结果容器：supplier方法
supplier方法必须返回一个结果为空的Supplier，也就是一个无参数函数，在调用时它会
创建一个空的累加器实例，供数据收集过程使用。

2. 将元素添加到结果容器：accumulator方法
accumulator方法会返回执行归约操作的函数。当遍历到流中第n个元素时，这个函数执行
时会有两个参数：保存归约结果的累加器（已收集了流中的前 n1 个项目），还有第n个元素本身。

3. 对结果容器应用最终转换：finisher方法
在遍历完流后，finisher方法必须返回在累积过程的最后要调用的一个函数，以便将累加
器对象转换为整个集合操作的最终结果。通常，就像ToListCollector的情况一样，累加器对
象恰好符合预期的最终结果，因此无需进行转换。 (Function.indentity() 相当于lambda: (t) -> t)

4. 合并两个结果容器：combiner方法
四个方法中的最后一个——combiner方法会返回一个供归约操作使用的函数，它定义了对
流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并。

5. characteristics方法
最后一个方法——characteristics会返回一个不可变的Characteristics集合，它定义
了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示。
Characteristics是一个包含三个项目的枚举。
 UNORDERED——归约结果不受流中项目的遍历和累积顺序的影响。
 CONCURRENT——accumulator函数可以从多个线程同时调用，且该收集器可以并行归
约流。如果收集器没有标为UNORDERED，那它仅在用于无序数据源时才可以并行归约。
 IDENTITY_FINISH——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种
情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器A不加检
查地转换为结果R是安全的。

15 stream 调试
List<Integer> result =
numbers.stream()
.peek(x -> System.out.println("from stream: " + x))
.map(x -> x + 17)
.peek(x -> System.out.println("after map: " + x))
.filter(x -> x % 2 == 0)
.peek(x -> System.out.println("after filter: " + x))
.limit(3)
.peek(x -> System.out.println("after limit: " + x))
.collect(toList());

16 接口 默认方法
Java 8引入了一个新功能，叫默认方法，通过默认方法
你可以指定接口方法的默认实现。换句话说，接口能提供方法的具体实现。因此，实现接口的类
如果不显式地提供该方法的具体实现，就会自动继承默认的实现。

如果一个类使用相同的函数签名从多个地方（比如另一个类或接口）继承了方法，通过三条
规则可以进行判断。
(1) 类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优
先级。
(2) 如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择
拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体。
(3) 最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，
显式地选择使用哪一个默认方法的实现。
public class C implements B, A {
	void hello(){
		B.super.hello();
	}
}

17 Optional
- 创建Optional 对象
1. 声明一个空的Optional
Optional<Car> optCar = Optional.empty();
2. 依据一个非空值创建Optional
Optional<Car> optCar = Optional.of(car);
如果car是一个null，这段代码会立即抛出一个NullPointerException，而不是等到你试图访问car的属性值时才返回一个错误。
3. 可接受null的Optional
最后，使用静态工厂方法Optional.ofNullable，你可以创建一个允许null值的Optional
对象：
Optional<Car> optCar = Optional.ofNullable(car);
如果car是null，那么得到的Optional对象就是个空对象。

- 样例类，用于下面的Optional解析
public class Person {
    private Optional<Car> car;

    public Person(Optional<Car> car){
        this.car = car;
    }

    public Optional<Car> getCar(){
        return car;
    }
}

public class Car {
    private Optional<Insurance> insurance;

    public Car(Optional<Insurance> insurance){
        this.insurance = insurance;
    }

    public Optional<Insurance> getInsurance(){
        return insurance;
    }
}

public class Insurance {
    private String name;
    public Insurance(String name){
        this.name = name;
    }

    public String getName(){
        return name;
    }

    public String toString(){
        return name;
    }
}

- 使用map 从Optional 对象中提取和转换值 (适用于只有一层Optional)
Optional<Insurance> optInsurance = Optional.ofNullable(insurance);
Optional<String> name = optInsurance.map(Insurance::getName);
从概念上，这与我们在第4章和第5章中看到的流的map方法相差无几。map操作会将提供的
函数应用于流的每个元素。你可以把Optional对象看成一种特殊的集合数据，它至多包含一个
元素。如果Optional包含一个值，那函数就将该值作为参数传递给map，对该值进行转换。如
果Optional为空，就什么也不做。

- 使用flatMap 链接Optional 对象 (适用于由多层Optional)
person.flatMap(Person::getCar)
      .flatMap(Car::getInsurance)
      .map(Insurance::getName)
      .orElse("Unknown");

- 默认行为及解引用Optional 对象
 get()是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量
值，否则就抛出一个NoSuchElementException异常。所以，除非你非常确定Optional
变量一定包含值，否则使用这个方法是个相当糟糕的主意。此外，这种方式即便相对于
嵌套式的null检查，也并未体现出多大的改进。
 orElse(T other)是我们在代码清单10-5中使用的方法，正如之前提到的，它允许你在
Optional对象不包含值时提供一个默认值。
 orElseGet(Supplier<? extends T> other)是orElse方法的延迟调用版，Supplier
方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作，
你应该考虑采用这种方式（借此提升程序的性能），或者你需要非常确定某个方法仅在
Optional为空时才进行调用，也可以考虑该方式（这种情况有严格的限制条件）。
 orElseThrow(Supplier<? extends X> exceptionSupplier)和get方法非常类似，
它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制希
望抛出的异常类型。
 ifPresent(Consumer<? super T>)让你能在变量值存在时执行一个作为参数传入的
方法，否则就不进行任何操作。

- 两个Optional 对象的组合
我们还假设你想要该方法的一个null-安全的版本，它接受两个Optional对象作为参数，返回值是一个Optional<Insurance>对象，如果传入的任何一个参数值为空，它的返回值亦为空。
public Optional<Insurance> nullSafeFindCheapestInsurance(Optional<Person> person, Optional<Car> car) {
	return person.flatMap(p -> car.map(c -> findCheapestInsurance(p, c)));
}

- 使用filter 剔除特定的值
使用Optional对象的filter方法，这段代码可以重构如下：
Optional<Insurance> optInsurance = ...;
optInsurance.filter(insurance ->
			"CambridgeInsurance".equals(insurance.getName()))
	    .ifPresent(x -> System.out.println("ok"));
filter方法接受一个谓词作为参数。如果Optional对象的值存在，并且它符合谓词的条件，
filter方法就返回其值；否则它就返回一个空的Optional对象

18 CompletableFuture
通过例子进行介绍

public class Shop {
    private Random random = new Random(37);
    private String name;

    public Shop(){
        this.name = "DefaultName";
    }

    public Shop(String name){
        this.name = name;
    }

    public String getName(){
        return name;
    }

    //同步方法
    public double getPrice(String product){
        return calculatePrice(product);
    }

    //传统应用Future的异步方法
    //通过新线程调用长时间执行的方法，调用后立即返回Future， 后面可以通过Future.get()来获取真是返回值
    public Future<Double> getPriceWithFuture(String product){
        ExecutorService service = Executors.newCachedThreadPool();
        Future<Double> futurePrice = service.submit(() ->calculatePrice(product));

        return futurePrice;
    }

    //应用新的CompletableFuture的异步方法
    //通过新线程调用长时间执行的方法，调用后立即返回Future， 后面可以通过Future.get()来获取真是返回值
    public Future<Double> getPriceAsync(String product){
        CompletableFuture<Double> futurePrice = new CompletableFuture<>();
        new Thread(()->{
                double price = calculatePrice(product);
                futurePrice.complete(price);
        }).start();

        return futurePrice;
    }
	
    ////应用新的CompletableFuture的异步方法，添加了异常处理
    public Future<Double> getPriceAsyncWithException(String product){
        CompletableFuture<Double> futurePrice = new CompletableFuture<>();
        new Thread(()->{
            try {
                double price = calculatePrice(product);
                futurePrice.complete(price);
            } catch (Exception ex) {
                futurePrice.completeExceptionally(ex);
            }
        }).start();

        return futurePrice;
    }

    //应用新的CompletableFuture的异步方法，通过supplyAsync获取CompletableFuture，好处是代码简介并且包含异常处理
    //it's the same as getPriceAsyncWithException including the exception handle, but it's simple to code with supplyAsync()
    public Future<Double> getPriceBySupplier(String product){
        return CompletableFuture.supplyAsync(() -> calculatePrice(product));
    }

    private double calculatePrice(String product){
        delay();
        if(product.equals("IPhone11")){
            throw new RuntimeException("Product is not available!");
        }

        return random.nextDouble() * product.charAt(0) + product.charAt(1);
    }

    private void doSomethingElse(){
        System.out.println("Do something else!");
    }

    public void delay(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void randomDelay() {
        int delay = 500 + random.nextInt(2000);
        try {
            Thread.sleep(delay);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    //测试应用了Future和CompletableFuture的异步方法
    public void testGetPriceWithFuture(String product, Function<String,Future<Double>> getPrice){
        Shop shop = new Shop();
        long start = System.nanoTime();
        Future<Double> futurePrice = getPrice.apply(product);
        long invocationTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Invocation returned after " + invocationTime + " msecs");

        shop.doSomethingElse();

        try {
            double price = futurePrice.get(1,TimeUnit.SECONDS);
            System.out.printf("Price is %.2f%n", price);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }

        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");
    }

    //测试同步方法
    public void testGetPrice(String product, Function<String,Double> getPrice){
        Shop shop = new Shop();
        long start = System.nanoTime();
        double price = getPrice.apply(product);
        long invocationTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Invocation returned after " + invocationTime + " msecs");
        System.out.printf("Price is %.2f%n", price);
        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");

        shop.doSomethingElse();
    }

    //测试同步方法
    public void testGetPriceWithShops(int n, String product){
        List<Shop> shops = getShops(n);

        long start = System.nanoTime();

        shops.parallelStream().map(shop ->
            String.format("%s price is %.2f\n",shop.getName(),shop.getPrice(product))
        ).collect(Collectors.toList());

        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");
    }

    //将同步方法转换为异步执行，对于一些老的同步方法的API，通过这种方法，可以提高执行速度
    public void testGetPriceWithShopsAndFuture(int n, String product){
        List<Shop> shops = getShops(n);

        long start = System.nanoTime();

        List<CompletableFuture<String>> list = shops.stream().map(
                                                shop -> CompletableFuture.supplyAsync(
                                                        () -> shop.getName()+"price is "+shop.calculatePrice(product)+"\n"))
                                            .collect(Collectors.toList());

        //through join, the map process will process the get() of each CompletableFuture one by one
        //it means it will invoke the next get() until previous get() complete
        list.stream().map(CompletableFuture::join).collect(Collectors.toList());

        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");
    }

    //将同步方法转换为异步执行，对于一些老的同步方法的API，通过这种方法，可以提高执行速度
    //通过指定自定义的线程池来定义开启线程的个数，从而获得更快的执行速度。
    //CompletableFuture.supplyAsync默认的线程个数是Runtime.getRuntime().availableProcessors()，通过自定义的线程池，可以根据需要来指定线程池大小。
    //use self defined Executor to define the number of thread,
    // for default, the number of thread is Runtime.getRuntime().availableProcessors()
    public void testGetPriceWithShopsAndFutureAndExecutor(int n, String product){
        List<Shop> shops = getShops(n);

        Executor executor =
                Executors.newFixedThreadPool(Math.min(shops.size(), 100),
                        new ThreadFactory() {
                            public Thread newThread(Runnable r) {
                                Thread t = new Thread(r);
                                t.setDaemon(true);
                                return t;
                            }
                        });

        long start = System.nanoTime();

        List<CompletableFuture<String>> list = shops.stream().map(
                shop -> CompletableFuture.supplyAsync(
                        () -> shop.getName()+"price is "+shop.calculatePrice(product)+"\n", executor))
                .collect(Collectors.toList());

        list.stream().map(CompletableFuture::join).collect(Collectors.toList());

        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");
    }

    public static List<Shop> getShops(int n){
        if (n > 0){
            List<Shop> shops = new ArrayList<>(n);
            for(int i=0;i<n;i++)
                shops.add(new Shop());
            return shops;
        }else
            return new ArrayList<Shop>();
    }

    public String getPriceWithDiscount(String product) {
        double price = calculatePrice(product);
        Discount.Code code = Discount.Code.values()[
                random.nextInt(Discount.Code.values().length)];
        return String.format("%s:%.2f:%s", name, price, code);
    }

    public void testGetPriceWithDiscount(int n, String product){
        List<Shop> shops = getShops(n);

        long start = System.nanoTime();
        shops.stream().map(shop -> shop.getPriceWithDiscount(product))
                .map(Quote::parse)
                .map(Discount::applyDiscount)
                .collect(Collectors.toList());
                //.forEach(System.out::println);

        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");
    }

    public void testGetPriceWithDiscountAndFuture(int n, String product){
        List<Shop> shops = getShops(n);

        Executor executor =
                Executors.newFixedThreadPool(Math.min(shops.size(), 100),
                        new ThreadFactory() {
                            public Thread newThread(Runnable r) {
                                Thread t = new Thread(r);
                                t.setDaemon(true);
                                return t;
                            }
                        });

        long start = System.nanoTime();

        List<CompletableFuture<String>> priceFutures = shops.stream().map(shop ->
                            CompletableFuture.supplyAsync(() -> shop.getPriceWithDiscount(product),executor))
                      .map(future -> future.thenApply(Quote::parse))
                      .map(future -> future.thenCompose(quote -> CompletableFuture.supplyAsync(() -> Discount.applyDiscount(quote),executor)))
                      .collect(Collectors.toList());

        priceFutures.stream().map(CompletableFuture::join).collect(Collectors.toList());

        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");
    }

    public void testGetPriceWithDiscountAndFutureAndRate(int n, String product){
        List<Shop> shops = getShops(n);

        Executor executor =
                Executors.newFixedThreadPool(Math.min(shops.size(), 100),
                        new ThreadFactory() {
                            public Thread newThread(Runnable r) {
                                Thread t = new Thread(r);
                                t.setDaemon(true);
                                return t;
                            }
                        });

        long start = System.nanoTime();
        //Supplier t = () -> ExchangeService.getRate(ExchangeService.Money.EUR, ExchangeService.Money.USD);
        List<CompletableFuture<String>> priceFutures = shops.stream().map(shop ->
                CompletableFuture.supplyAsync(() -> shop.getPriceWithDiscount(product),executor))
                .map(future -> future.thenApply(Quote::parse))
                .map(future -> future.thenCompose(quote -> CompletableFuture.supplyAsync(() -> Discount.applyDiscount(quote),executor)))
                .map(future -> future.thenCombine(CompletableFuture.supplyAsync(() -> ExchangeService.getRate(ExchangeService.Money.EUR, ExchangeService.Money.USD)),
                                                  (price,rate) -> price +" rate: "+rate))
                .collect(Collectors.toList());

        priceFutures.stream().map(CompletableFuture::join).forEach(System.out::println);

        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");
    }

    public void testGetPriceWithDiscountAndFutureAndRateWithAccept(int n, String product){
        List<Shop> shops = getShops(n);

        Executor executor =
                Executors.newFixedThreadPool(Math.min(shops.size(), 100),
                        new ThreadFactory() {
                            public Thread newThread(Runnable r) {
                                Thread t = new Thread(r);
                                t.setDaemon(true);
                                return t;
                            }
                        });

        long start = System.nanoTime();

        CompletableFuture[] priceFutures = shops.stream().map(shop ->
                CompletableFuture.supplyAsync(() -> shop.getPriceWithDiscount(product),executor))
                .map(future -> future.thenApply(Quote::parse))
                .map(future -> future.thenCompose(quote -> CompletableFuture.supplyAsync(() -> Discount.applyDiscount(quote),executor)))
                .map(future -> future.thenCombine(CompletableFuture.supplyAsync(() -> ExchangeService.getRate(ExchangeService.Money.EUR, ExchangeService.Money.USD)),
                        (price,rate) -> price +" rate: "+rate))
                .map(future -> future.thenAccept(s ->
                                        System.out.println(s + " (done in " + ((System.nanoTime() - start) / 1_000_000) + " msecs)")))
                .toArray(size -> new CompletableFuture[size]);

        CompletableFuture.allOf(priceFutures).join();

        long retrievalTime = ((System.nanoTime() - start) / 1_000_000);
        System.out.println("Price returned after " + retrievalTime + " msecs");
    }

    public static void main(String[] args){
        Shop shop = new Shop();
        //shop.testGetPriceWithFuture("IPhone12",shop::getPriceBySupplier);
        //shop.testGetPrice("IPhone12",shop::getPrice);
        System.out.println("testGetPriceWithShops");
        shop.testGetPriceWithShops(20,"IPhone12");
        System.out.println("testGetPriceWithShopsAndFuture");
        shop.testGetPriceWithShopsAndFuture(20,"IPhone12");
        System.out.println("testGetPriceWithShopsAndFutureAndExecutor");
        shop.testGetPriceWithShopsAndFutureAndExecutor(20,"IPhone12");
    }
}

package tk.chap11;

public class Quote {
    private final String shopName;
    private final double price;
    private final Discount.Code discountCode;
    public Quote(String shopName, double price, Discount.Code code) {
        this.shopName = shopName;
        this.price = price;
        this.discountCode = code;
    }

    public static Quote parse(String s) {
        String[] split = s.split(":");
        String shopName = split[0];
        double price = Double.parseDouble(split[1]);
        Discount.Code discountCode = Discount.Code.valueOf(split[2]);
        return new Quote(shopName, price, discountCode);
    }
    public String getShopName() { return shopName; }
    public double getPrice() { return price; }
    public Discount.Code getDiscountCode() { return discountCode; }
}


package tk.chap11;

public class Discount {
    public enum Code {
        NONE(0), SILVER(5), GOLD(10), PLATINUM(15), DIAMOND(20);
        private final int percentage;

        Code(int percentage) {
            this.percentage = percentage;
        }
    }

    public static void delay(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static String applyDiscount(Quote quote) {
        return quote.getShopName() + " price is " +
                Discount.apply(quote.getPrice(),
                        quote.getDiscountCode());
    }
    private static double apply(double price, Code code) {
        delay();
        return price * (100 - code.percentage) / 100;
    }
}


package tk.chap11;

public class ExchangeService {
    public enum Money{
        USD(1),
        EUR(1.6);

        private double value;

        Money(double value){
            this.value = value;
        }

        public double getValue(){
            return value;
        }
    }

    public static double getRate(Money m1, Money m2){
        return m1.getValue()/m2.getValue();
    }
}

并行——使用流还是CompletableFutures？
目前为止，你已经知道对集合进行并行计算有两种方式：要么将其转化为并行流，利用map
这样的操作开展工作，要么枚举出集合中的每一个元素，创建新的线程，在Completable-
Future内对其进行操作。后者提供了更多的灵活性，你可以调整线程池的大小，而这能帮助
你确保整体的计算不会因为线程都在等待I/O而发生阻塞。
我们对使用这些API的建议如下。

❑如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实
现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要
创建比处理器核数更多的线程）。

❑反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用
CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者
W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的
流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。

利用CompletableFuture可以：
为你的用户提供异步API， 参考方法 getPriceBySupplier
以及如何将一个同步又缓慢的服务转换为异步的服务 

还可以将多个同步又缓慢的服务转换为并行流  参考方法 testGetPriceWithShopsAndFutureAndExecutor

-CompletableFuture.thenCompose
Java 8的 CompletableFuture API提供了名为thenCompose的方法，它就是专门为这一目
的而设计的，thenCompose方法允许你对两个异步操作进行流水线，第一个操作完成时，将其
结果作为参数传递给第二个操作。换句话说，你可以创建两个CompletableFutures对象，对
第一个CompletableFuture 对象调用thenCompose ， 并向其传递一个函数。当第一个
CompletableFuture执行完毕后，它的结果将作为该函数的参数，这个函数的返回值是以第一
个CompletableFuture的返回做输入计算出的第二个CompletableFuture对象。

通常而言，名称中不带Async
的方法和它的前一个任务一样，在同一个线程中运行；而名称以Async结尾的方法会将后续的任
务提交到一个线程池，所以每个任务是由不同的线程处理的。

thenComposeAsync 
A.thenComposeAsync(B)
就是说前面的A执行的时候，注册B为一个回调函数，当A完成了就另起一个线程执行B
A.thenCompose(B)就是在A执行完了后，在当前线程继续执行B

- thenCombine
另一种比较常见的情况是，你需要将两个完
全不相干的CompletableFuture对象的结果整合起来，而且你也不希望等到第一个任务完全结
束才开始第二项任务。
这种情况，你应该使用thenCombine方法，它接收名为BiFunction的第二参数，这个参数
定义了当两个CompletableFuture对象完成计算后，结果如何合并。同thenCompose方法一样，
thenCombine方法也提供有一个Async的版本。这里，如果使用thenCombineAsync会导致
BiFunction中定义的合并操作被提交到线程池中，由另一个任务以异步的方式执行。

Future<Double> futurePriceInUSD = CompletableFuture.supplyAsync(() -> shop.getPrice(product))
				 .thenCombine(
					CompletableFuture.supplyAsync(
						() -> exchangeService.getRate(Money.EUR, Money.USD)),
			                (price, rate) -> price * rate
);

- applyAccept
CompletableFuture 通过thenAccept 方法提供了这一功能， 它接收CompletableFuture执行完毕后的返回值做参数。
findPricesStream("myPhone").map(f -> f.thenAccept(System.out::println));
由于thenAccept 方法已经定义了如何处理CompletableFuture 返回的结果，一旦
CompletableFuture计算得到结果，它就返回一个CompletableFuture<Void>。所以，map
操作返回的是一个Stream<CompletableFuture<Void>>

- allof, anyof
allOf工厂方法接收一个由CompletableFuture构成的数组，数组中的所有Completable-
Future对象执行完成之后，它返回一个CompletableFuture<Void>对象。这意味着，如果你需
要等待最初Stream 中的所有CompletableFuture 对象执行完毕， 对allOf 方法返回的
CompletableFuture执行join操作是个不错的主意。

然而在另一些场景中，你可能希望只要CompletableFuture对象数组中有任何一个执行完
毕就不再等待，比如，你正在查询两个汇率服务器，任何一个返回了结果都能满足你的需求。在
这种情况下，你可以使用一个类似的工厂方法anyOf。该方法接收一个CompletableFuture对象
构成的数组，返回由第一个执行完毕的CompletableFuture对象的返回值构成的Completable-
Future<Object>。

