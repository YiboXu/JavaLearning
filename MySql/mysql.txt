显示系统字符集
mysql> show variables like '%char%';
+--------------------------+--------------------------------+
| Variable_name            | Value                          |
+--------------------------+--------------------------------+
| character_set_client     | utf8mb4                        |
| character_set_connection | utf8mb4                        |
| character_set_database   | utf8mb4                        |
| character_set_filesystem | binary                         |
| character_set_results    | utf8mb4                        |
| character_set_server     | utf8mb4                        |
| character_set_system     | utf8                           |
| character_sets_dir       | /usr/share/mysql-8.0/charsets/ |
+--------------------------+--------------------------------+

显示mysql所提供的存储引擎
mysql> show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+

显示当前使用的存储引擎
mysql> show variables like '%storage_engine%';
+---------------------------------+-----------+
| Variable_name                   | Value     |
+---------------------------------+-----------+
| default_storage_engine          | InnoDB    |
| default_tmp_storage_engine      | InnoDB    |
| disabled_storage_engines        |           |
| internal_tmp_mem_storage_engine | TempTable |
+---------------------------------+-----------+

MyISAM 对比 InnoDB
对比项			MyISAM 					InnoDB
外键			不支持					支持
事务			不支持					支持
行表锁			表锁，即使操作一条记录也会锁住整个表，       行锁,操作时只锁某一行，不对其它行有影响，
			不适合高并发的操作			适合高并发的操作
缓存			只缓存索引，不缓存真实数据			不仅缓存索引还要缓存真实数据，对内存要求较高，而且内
								存大小对性能有决定性的影响
关注点			读性能					并发写、事务、资源
默认安装			Y 					Y
默认使用			N 					Y
自带系统表使用		Y 					N

MyISAM实用于高效率读取的场景，不适合有事务的场景, 而InnoDB适合有事务的场景

- MySql不支持full outer join, 需要的时候用left join UNION right join, UNION自带去重功能
select * from t_emp emp left join t_dept dept on emp.deptId = dept.id 
union 
select * from t_emp emp right join t_dept dept on emp.deptId = dept.id;

mysql> select * from t_emp emp left join t_dept dept on emp.deptId = dept.id
    -> union
    -> select * from t_emp emp right join t_dept dept on emp.deptId = dept.id;
+------+--------+------+--------+--------+------+----------+---------+
| id   | name   | age  | deptId | empno  | id   | deptName | address |
+------+--------+------+--------+--------+------+----------+---------+
|    1 | BillHu |   37 |      1 | 100001 |    1 | RD       | f11     |
|    2 | Sofica |   37 |      2 | 100002 |    2 | HR       | f12     |
|    3 | Sara   |    8 |      3 | 100003 |    3 | MK       | f13     |
|    4 | Tina   |    2 |      4 | 100004 |    4 | MIS      | f14     |
|    5 | Jim    |   50 |      5 | 100005 |    5 | FD       | f15     |
|    6 | Kerry  |   48 |      1 | 100006 |    1 | RD       | f11     |
|    7 | Eileen |   45 |      5 | 100007 |    5 | FD       | f15     |
|    8 | Milan  |   40 |      3 | 100008 |    3 | MK       | f13     |
|    9 | Peter  |   40 |     51 | 100009 | NULL | NULL     | NULL    |
| NULL | NULL   | NULL |   NULL |   NULL |    6 | boss     | top     |
+------+--------+------+--------+--------+------+----------+---------+

- 索引index
索引是一种帮助MySql高效获取数据的数据结构.
可以将索引理解为"排好序的快速查找数据结构"
索引会影响到where和order by

数据本身之外，数据库还维护者一个满足特定查找算法的数据结构(比如B树)，这些数据结构以某种方式指向数据，
这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引.

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上.

创建index
CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));
ALTER mytable ADD [UNIQUE] INDEX [indexName] on (columnname(length));
删除index
DROP INDEX [indexName] ON mytable;
查看index
SHOW INDEX FROM table_name\G
有四种方式来添加数据表的索引:
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list) 该语句添加一个主键，这意味着索引值是唯一的，且不能为NULL
ALTER TABLE tbl_name ADD UNIQUE index_name (column_list)这条语句创建索引的值必须是唯一的 (除了NULL外，NULL可能会出现多次)
ALTER TABLE tbl_name ADD INDEX index_name (column_list) 添加普通索引，索引值可以出现多次.
ALTER TABLE tbl_name ADD FULLTEXT index_name(column_list) 该语句指定了索引为FULLTEXT， 用于全文索引.


索引结构
Hash
full-text
RR-Tree
BTree(重点)


适合创建索引的情况
- 主键自动建立唯一索引；
- 频繁作为查询条件的字段应该创建索引
- 查询中与其它表关联的字段，外键关系建立索引
- 单键/组合索引的选择问题， 组合索引性价比更高
- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
- 查询中统计或者分组字段

不适合创建索引的情况
- 表记录太少
- 经常增删改的表或者字段
- Where 条件里用不到的字段不创建索引
- 过滤性不好的不适合建索引
- 数据重复且分布平均的表字段 


性能分析 Explain
- 是什么:
查看执行计划
- 能干嘛:
表的读取顺序
数据读取操作的操作类型
哪些索引可以使用
哪些索引被实际使用
表之间的引用
每张表有多少行被优化器查询
- 怎么用(EXPLAIN + sql语句)
mysql> explain select * from t_emp;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | t_emp | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

- explain 结果
准备工作
CREATE TABLE t1(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));
CREATE TABLE t2(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));
CREATE TABLE t3(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));
CREATE TABLE t4(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));
INSERT INTO t1(content) VALUES('t1_137');
INSERT INTO t2(content) VALUES('t2_392');
INSERT INTO t3(content) VALUES('t3_550');
INSERT INTO t4(content) VALUES('t4_571');

- id 
①id 相同，执行顺序由上至下
mysql> explain select * from t1,t2,t3 where t1.id=t2.id AND t2.id=t3.id;
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------+------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref          | rows | filtered | Extra |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------+------+----------+-------+
|  1 | SIMPLE      | t1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL         |    1 |   100.00 | NULL  |
|  1 | SIMPLE      | t2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | mydb01.t1.id |    1 |   100.00 | NULL  |
|  1 | SIMPLE      | t3    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | mydb01.t1.id |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------+------+----------+-------+

②id 不同，id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行
mysql> EXPLAIN SELECT t1.id FROM t1 where t1.id = ( SELECT t2.id FROM t2 WHERE t2.id = ( SELECT t3.id FROM t3 WHERE t3.content = 't3_550'));
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | t1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index |
|  2 | SUBQUERY    | t2    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index |
|  3 | SUBQUERY    | t3    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    1 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+

③有相同也有不同
id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行
衍生= DERIVED

关注点：id 号每个号码，表示一趟独立的查询。一个sql 的查询趟数越少越好。

select_type
select_type 代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。
select_type 			属性含义
SIMPLE 				简单的select 查询,查询中不包含子查询或者UNION
PRIMARY 			查询中若包含任何复杂的子部分，最外层查询则被标记为Primary
DERIVED 			在FROM 列表中包含的子查询被标记为DERIVED(衍生) MySQL会递归执行这些子查询, 把结果放在临时表里。
SUBQUERY 			在SELECT或WHERE列表中包含了子查询
DEPEDENT SUBQUERY 		在SELECT或WHERE列表中包含了子查询,子查询基于外层
UNCACHEABLE SUBQUERY 		无法使用缓存的子查询
UNION 				若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED
UNION RESULT 			从UNION表获取结果的SELECT

table 表名
partitions 分区
type 访问类型
显示查询使用了何种类型， 从最好到最差依次是: system > const > eq_ref > ref > range > index > ALL
  -system表只有一行记录（等于系统表），这是const 类型的特列，平时不会出现，这个也可以忽略不计
  -const表示通过索引一次就找到了,const 用于比较primary key 或者unique 索引。
  -eq_ref唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。
  -ref非唯一性索引扫描，返回匹配某个单独值的所有行.
  -range 只检索给定范围的行,使用一个索引来选择行。  (select * from table where id between 1 and 10;)
  -index出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。  (select id from t1;  id是索引列)
  -all 全表扫描 (select * from t1)

至少达到range级别，最好是ref

possible_keys
显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。
key
实际使用的索引。如果为NULL，则没有使用索引。
查询中若使用了覆盖索引，则该索引仅出现在key列表中.

什么是覆盖索引? 
(就是查询的字段和定义的索引字段匹配，就是select的数据列只用从索引中就能够取得，不必使用索引的键值再去读取底层文件,换句话说，查询列要被所建的索引覆盖)

mysql> explain select name,deptId from t_emp;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | t_emp | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> create index idx1_emp on t_emp(name,deptId);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select name,deptId from t_emp;
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_emp | NULL       | index | NULL          | idx1_emp | 68      | NULL |    9 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+


key_len
表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len 字段能够帮你检查是否充分的
利用上了索引。ken_len 越长，说明索引使用的越充分。
但是注意，在不损失精确性的情况下，长度越短越好，因为越短，比较的效率越高.

ref
显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。

rows
rows 列显示MySQL 认为它执行查询时必须检查的行数。越少越好！

filtered
Extra
Using filesort
说明mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。
mysql> explain select * from t_emp where deptId = 2 order by deptId,name;
+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key         | key_len | ref   | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+----------------+
|  1 | SIMPLE      | t_emp | NULL       | ref  | idx_dept_id   | idx_dept_id | 5       | const |    1 |   100.00 | Using filesort |
+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+----------------+
1 row in set, 1 warning (0.00 sec)

mysql> create index idx_emp_deptId_name on t_emp(deptId,name);
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from t_emp where deptId = 2 order by deptId,name;
+----+-------------+-------+------------+------+---------------------------------+---------------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys                   | key                 | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------------------------+---------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_emp | NULL       | ref  | idx_dept_id,idx_emp_deptId_name | idx_emp_deptId_name | 5       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------------------------+---------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

==========================================
结论: order by的字段和顺序要和对应索引一致  |
==========================================

Using temporary 
使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。常见于排序order by 和分组查询groupby。
mysql> explain select name from t_emp where deptId in(1,2,3) group by deptId, name;
+----+-------------+-------+------------+-------+----------------------+----------+---------+------+------+----------+-------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys        | key      | key_len | ref  | rows | filtered | Extra                                     |
+----+-------------+-------+------------+-------+----------------------+----------+---------+------+------+----------+-------------------------------------------+
|  1 | SIMPLE      | t_emp | NULL       | index | idx_dept_id,idx1_emp | idx1_emp | 68      | NULL |    9 |    55.56 | Using where; Using index; Using temporary |
+----+-------------+-------+------------+-------+----------------------+----------+---------+------+------+----------+-------------------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> create index idx_emp_deptId_name on t_emp(deptId,name);
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select name from t_emp where deptId in(1,2,3) group by deptId, name;
+----+-------------+-------+------------+-------+------------------------------------------+---------------------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys                            | key                 | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+------------------------------------------+---------------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t_emp | NULL       | range | idx_dept_id,idx1_emp,idx_emp_deptId_name | idx_emp_deptId_name | 5       | NULL |    5 |   100.00 | Using where; Using index |
+----+-------------+-------+------------+-------+------------------------------------------+---------------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

==========================================
结论: group by的字段和顺序要和对应索引一致  |
==========================================

Using index 代表表示相应的select 操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！
如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。
mysql> explain select deptId, name from t_emp;      ====>仅仅从索引中读取数据来返回，因为要查询的deptId, name这2个字段就在索引中，并且没有where条件.
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_emp | NULL       | index | NULL          | idx1_emp | 68      | NULL |    9 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select deptId, name from t_emp where deptId in(1,2,3);            ====>where的存在，使得索引被用来执行索引键值的查找
+----+-------------+-------+------------+-------+---------------------------------+---------------------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys                   | key                 | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------------------------+---------------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t_emp | NULL       | range | idx_dept_id,idx_emp_deptId_name | idx_emp_deptId_name | 5       | NULL |    5 |   100.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------------------------+---------------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

Using join buffer (左连接中，右表没有在join on字段上建立索引的时候，会产生连接缓存)
mysql> explain select * from class class left join book book on class.card = book.card;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | class | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | NULL                                               |
|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+

索引单表优化
- 建表
CREATE TABLE IF NOT EXISTS article(
id INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
author_id INT(10) UNSIGNED NOT NULL,
category_id INT(10) UNSIGNED NOT NULL,
views INT(10) UNSIGNED NOT NULL,
comments INT(10) UNSIGNED NOT NULL,
title VARBINARY(255) NOT NULL,
content TEXT NOT NULL
);

INSERT INTO article(author_id, category_id, views, comments, title, content) 
values
(1,1,1,1,'1','1'),
(2,2,2,2,'2','2'),
(3,1,3,3,'3','3');

-查询
mysql> select * from article where category_id=1 and comments > 1 order by views DESC LIMIT 1;
+----+-----------+-------------+-------+----------+--------------+---------+
| id | author_id | category_id | views | comments | title        | content |
+----+-----------+-------------+-------+----------+--------------+---------+
|  3 |         3 |           1 |     3 |        3 | 0x33         | 3       |
+----+-----------+-------------+-------+----------+--------------+---------+
1 row in set (0.00 sec)

-查看性能
mysql> explain select * from article where category_id=1 and comments > 1 order by views DESC LIMIT 1;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+
|  1 | SIMPLE      | article | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using filesort |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+
1 row in set, 1 warning (0.00 sec)

-优化
尝试一: (where里面的用到的字段添加索引)
mysql> create index idx_views on article(category_id, comments, views DESC);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from article where category_id=1 and comments > 1 order by views DESC LIMIT 1;
+----+-------------+---------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+
| id | select_type | table   | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+---------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | article | NULL       | range | idx_views     | idx_views | 8       | NULL |    1 |   100.00 | Using index condition; Using filesort |
+----+-------------+---------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+

type 由 ALL 变为了 range， 但是 Extra 里面依然存在 Using filesort 文件内排序
为什么会这样呢?
这是因为按照BTree索引的工作原理, 先排序category_id， 如果遇到相同的category_id则再排序comments,如果遇到相同的comments，则再排序views。
当comments字段再联合索引里处于中间位置时, 因comments>1条件是一个范围值(所谓range),MySQL无法利用索引再对后面的views部分进行检索，
即range类型查询字段后面的索引(字段)无效.

尝试二:
mysql> create index idx_cv on article(category_id, views DESC);
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from article where category_id=1 and comments > 1 order by views DESC LIMIT 1;
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | article | NULL       | ref  | idx_cv        | idx_cv | 4       | const |    2 |    33.33 | Using where |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------------+

尝试三:
mysql> create index idx_cv on article(category_id, views DESC,comments);
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from article where category_id=1 and comments > 1 order by views DESC LIMIT 1;
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-----------------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | article | NULL       | ref  | idx_cv        | idx_cv | 4       | const |    2 |    33.33 | Using index condition |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-----------------------+


结论: 尝试二和三都可以




索引双表优化
-建表
CREATE TABLE IF NOT EXISTS class(
id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
card INT(10) UNSIGNED NOT NULL,
PRIMARY KEY(id)
);

CREATE TABLE IF NOT EXISTS book(
bookid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
card INT(10) UNSIGNED NOT NULL,
PRIMARY KEY(bookid)
);

INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));

INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));


-查看性能
mysql> explain select * from class class left join book book on class.card = book.card;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | class | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | NULL                                               |
|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+

- 尝试一 (索引加在左连接的左表)
mysql> create index idx_card on class(card);
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from class class left join book book on class.card = book.card;
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | class | NULL       | index | NULL          | idx_card | 4       | NULL |   20 |   100.00 | Using index                                        |
|  1 | SIMPLE      | book  | NULL       | ALL   | NULL          | NULL     | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+----------------------------------------------------+

- 尝试二 (索引加在左连接的右表)
mysql> create index idx_card on book(card);
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from class class left join book book on class.card = book.card;
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+
|  1 | SIMPLE      | class | NULL       | ALL  | NULL          | NULL     | NULL    | NULL              |   20 |   100.00 | NULL        |
|  1 | SIMPLE      | book  | NULL       | ref  | idx_card      | idx_card | 4       | mydb01.class.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+

我们看到 type, rows都有了优化. 这是由左连接特性决定的， LEFT JOIN体哦阿健用于确定偈从右边搜索行，左表一定都有.

- 尝试三 (索引在左连接的左右表上都加)

mysql> create index idx_card on class(card);
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> create index idx_card on book(card);
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from class class left join book book on class.card = book.card;
+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref               | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------+
|  1 | SIMPLE      | class | NULL       | index | NULL          | idx_card | 4       | NULL              |   20 |   100.00 | Using index |
|  1 | SIMPLE      | book  | NULL       | ref   | idx_card      | idx_card | 4       | mydb01.class.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------+

- 结论
对于2表join的查询， left join将索引建在右表上; right join将索引建在左表上; 左右表都建索引也是可以的，索引的字段由join on的字段决定.



索引三表优化
-建表 (在双表优化的基础上添加新表)
CREATE TABLE IF NOT EXISTS phone (
phoneid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
card INT(10) UNSIGNED NOT NULL,
PRIMARY KEY(phoneid)
)ENGINE = INNODB;

INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));

- 性能查询
(先将book，class上的索引删除)
mysql> explain select * from class class left join book book on class.card=book.card left join phone phone on class.card = phone.card;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | class | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | NULL                                               |
|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (Block Nested Loop) |
|  1 | SIMPLE      | phone | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+

- 优化 
根据双标优化的策略，左连接在右表建索引，所以这里需要在book和phone上在card字段建立索引
mysql> create index idx_card on book(card);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> create index idx_card on phone(card);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from class class left join book book on class.card=book.card left join phone phone on class.card = phone.card;
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+
|  1 | SIMPLE      | class | NULL       | ALL  | NULL          | NULL     | NULL    | NULL              |   20 |   100.00 | NULL        |
|  1 | SIMPLE      | book  | NULL       | ref  | idx_card      | idx_card | 4       | mydb01.class.card |    1 |   100.00 | Using index |
|  1 | SIMPLE      | phone | NULL       | ref  | idx_card      | idx_card | 4       | mydb01.class.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+

单表及多表优化总结:
-索引最好建立在经常查询的字段上
-尽可能减少join语句中的NestedLoop的循环次数: "永远用小结果集驱动大的结果集".
-优先优化NestedLoop的内层循环.
-保证Join语句中被驱动表上Join条件字段已经被索引 (左连接在右表建索引，右连接在左表建索引, 内连接在任意一边表建立索引)
-当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置.


索引优化
-建表
CREATE TABLE staffs(
id INT PRIMARY KEY AUTO_INCREMENT,
name varchar(24) NOT NULL DEFAULT '' COMMENT 'name',
age INT NOT NULL DEFAULT 0 COMMENT 'age',
pos VARCHAR(20) NOT NULL DEFAULT '' COMMENT 'position',
add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'join time'
)CHARSET utf8 COMMENT 'staff table';

INSERT INTO staffs(name, age, pos, add_time) VALUES('z3',22,'manager',NOW());
INSERT INTO staffs(name, age, pos, add_time) VALUES('July',23,'dev',NOW());
INSERT INTO staffs(name, age, pos, add_time) VALUES('2000',23,'dev',NOW());

CREATE INDEX idx_staffs_nameAgePos(name,age,pos);

-准则
1. 全值匹配
where 中匹配索引中所有列
2. 最佳做前缀法则
如果索引有多列，要遵守最左前缀法则，指的时查询从索引的最左列开始并且不跳过中间列.
mysql> explain select * from staffs where age = 23;
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from staffs where pos = 'dev';
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from staffs where name='July' and age='23' and pos='dev';
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref               | rows | filtered | Extra |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | staffs | NULL       | ref  | idx_nameAgePos | idx_nameAgePos | 140     | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------+

我们看到只有按照索引的列来查询才能用到索引，这样才是最优的查询. 
(注意不用保证顺序，只有order by和group by需要保证和索引字段顺序一致，因为对于and连接，MySql自带的优化器会将其重新按索引的顺序排列, 但是最好还是按照索引字段顺序来，可以避免优化器的额外工作)

3. 不再索引上做任何操作(计算，函数，(自动or手动)类型转换, 会导致索引失效而转向全表扫描)
mysql> explain select * from staffs where name='July';
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | staffs | NULL       | ref  | idx_nameAgePos | idx_nameAgePos | 74      | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from staffs where left(name,4) = 'July';
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+

4. 寸尺引擎不能使用索引中范围条件右边的列
mysql> explain select * from staffs where name = 'July' and age = 20 and pos='dev';
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref               | rows | filtered | Extra |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | staffs | NULL       | ref  | idx_nameAgePos | idx_nameAgePos | 140     | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from staffs where name = 'July' and age > 20 and pos='dev';
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
| id | select_type | table  | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | staffs | NULL       | range | idx_nameAgePos | idx_nameAgePos | 78      | NULL |    1 |    33.33 | Using index condition |
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+

我们看到使用age > 20后，type变成了range， 同时key_len也变短了，查询效率变低了.

5. 精良使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select *
mysql> explain select * from staffs where name = 'July' and age = 20 and pos='manager';
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref               | rows | filtered | Extra |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | staffs | NULL       | ref  | idx_nameAgePos | idx_nameAgePos | 140     | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select name,age,pos from staffs where name = 'July' and age = 20 and pos='manager';
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref               | rows | filtered | Extra       |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------------+
|  1 | SIMPLE      | staffs | NULL       | ref  | idx_nameAgePos | idx_nameAgePos | 140     | const,const,const |    1 |   100.00 | Using index |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------------------+------+----------+-------------+

只获取索引上的列后，Extra里面多了Using Index, 查询效率变高了，原因时只用从索引键值上获取需要的列，不用通过索引键值去底层文件查询.
6. mysql在使用不等于(!=或者<>)的时候无法使用索引会导致全表扫描
mysql> explain select * from staffs where name='July';
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | staffs | NULL       | ref  | idx_nameAgePos | idx_nameAgePos | 74      | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select * from staffs where name!='July';
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
| id | select_type | table  | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | staffs | NULL       | range | idx_nameAgePos | idx_nameAgePos | 74      | NULL |    2 |   100.00 | Using index condition |
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+

7. is null, is not null也无法使用索引
mysql> explain select * from staffs where name is null;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from staffs where name is not null;
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |   100.00 | NULL  |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+

8. like以通配符开头('%abc...')mysql索引失效会变成全表扫描的操作
mysql> explain select * from staffs where name like '%July%';
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from staffs where name like '%July';
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from staffs where name like 'July%';
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
| id | select_type | table  | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | staffs | NULL       | range | idx_nameAgePos | idx_nameAgePos | 74      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+

like最好将%放右边

如果因为业务需要，必须用到%...%，那么将对需要返回的列创建索引，这样就可以通过索引覆盖，将返回的值从索引键值上获取，而不用查询底层文件，从而最终在使用%...%的情况下避免了全表扫描
mysql> explain select * from staffs where name like '%aa%';
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | staffs | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    8 |    12.50 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

CREATE INDEX idx_staffs_nameAgePos(name,age,pos);

mysql> explain select name,age,pos from staffs where name like '%aa%';
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+--------------------------+
| id | select_type | table  | partitions | type  | possible_keys | key            | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | staffs | NULL       | index | NULL          | idx_nameAgePos | 140     | NULL |    8 |    12.50 | Using where; Using index |
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+--------------------------+

注意下面这个查询，id虽然不是和name,age,pos在一个索引上，但是id自身是主键，也是一个索引的键值，从而整个查询也用到了覆盖索引，不用去底层文件查询.
mysql> explain select id,name,age,pos from staffs where name like '%aa%';
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+--------------------------+
| id | select_type | table  | partitions | type  | possible_keys | key            | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | staffs | NULL       | index | NULL          | idx_nameAgePos | 140     | NULL |    8 |    12.50 | Using where; Using index |
+----+-------------+--------+------------+-------+---------------+----------------+---------+------+------+----------+--------------------------+

9. 字符串不加单引号索引失效
mysql> explain select * from staffs where name = 2000;
+----+-------------+--------+------------+------+----------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys  | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+----------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | staffs | NULL       | ALL  | idx_nameAgePos | NULL | NULL    | NULL |    8 |    12.50 | Using where |
+----+-------------+--------+------------+------+----------------+------+---------+------+------+----------+-------------+

因为2000被自动转换为varchar类型 

10 少用or, 用它来连接时会索引失效
mysql> explain select * from staffs where name = 'z23' or age = 21;
+----+-------------+--------+------------+------+----------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys  | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+----------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | staffs | NULL       | ALL  | idx_nameAgePos | NULL | NULL    | NULL |    8 |    23.44 | Using where |
+----+-------------+--------+------------+------+----------------+------+---------+------+------+----------+-------------+

索引优化建议:
- 对于单键索引, 尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候， 当前query中过滤醒最好的字段在索引字段顺序中，位置越靠前越好.
- 在选择组合索引的时候， 尽量选择可以能够包含当前query中的where中更多字段的索引.
- 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的.

==============================================================================================================================
+----+-------------+--------+------------+------+----------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys  | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+----------------+------+---------+------+------+----------+-------------+
通过EXPLAIN分析一个SQL后，首先看type, 至少达到range级别 (system > const > eq_ref > ref > range > index > ALL)
对于range级别相同的情况，在看是否用到索引， 看 key
然后再看key_len，相同的range级别下，key_len越长说明对索引的利用越充分，查询效率越高
最后看Extra里面是否有Using temporary或Using filesort，如果有的化，一定要消除掉

对于如何查看用到多少一个索引的字段，一般按照索引定义的字段及顺序在where语句里面匹配常量值， 然后出现 <>符号的，索引用到第一个用于指定范围的字段，注意， like 'aa%' 跟 <> 不一样，会算入索引使用的字段
==============================================================================================================================



SQL分析步骤：
1. 观察， 至少跑1天, 看看生产的慢SQL情况
2. 开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来.
3. explain + 慢SQL分析
4. show profile查询SQL在MySql服务器里面的执行细节和生命周期情况
5. 运维或DBA进行SQL数据库服务器的参数调优

- 查询优化
1. 小表驱动大表
当B表的数据集效于A表的数据集时，用in优于exists
select * from A where id in (select id from B)
等价于:
for select id from B:
  for select * from A where A.id = B.id

当A表数据集小于B表数据集时，用exists由于in
select * from A where exists (select 1 from B where B.id = A.id)
等价于:
for select * from A:
  for select * from B where B.id = A.id

注意: A表和B表的ID字段应建立索引.
select * from A where exist

============explain优化的时where 之后, order by/group by之前================================
2. ORDER BY子句，尽量使用Index方式排序，避免使用filesort方式排序

-建表
CREATE TABLE tblA(
 #id int primary key not null auto_increment,
 age INT,
 birth TIMESTAMP NOT NULL
);

INSERT INTO tblA(age,birth) VALUES(22, NOW());
INSERT INTO tblA(age,birth) VALUES(22, NOW());
INSERT INTO tblA(age,birth) VALUES(22, NOW());

CREATE INDEX idx_ageBirth ON tblA(age,birth);

SELECT * FROM tblA;

- 查看性能
mysql> explain select * from tblA where age > 20 order by age;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | idx_ageBirth  | idx_ageBirth | 9       | NULL |    3 |   100.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> mysql> explain select * from tblA where age > 20 order by age, birth;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | idx_ageBirth  | idx_ageBirth | 9       | NULL |    3 |   100.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from tblA where age > 20 order by birth;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | idx_ageBirth  | idx_ageBirth | 9       | NULL |    3 |   100.00 | Using where; Using index; Using filesort |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from tblA where age > 20 order by birth, age;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | idx_ageBirth  | idx_ageBirth | 9       | NULL |    3 |   100.00 | Using where; Using index; Using filesort |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+

mysql> explain select * from tblA order by birth;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                       |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | NULL          | idx_ageBirth | 9       | NULL |    3 |   100.00 | Using index; Using filesort |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from tblA where birth > '2018-01-01 00:00:00' order by birth;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | idx_ageBirth  | idx_ageBirth | 9       | NULL |    3 |    33.33 | Using where; Using index; Using filesort |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+

mysql> explain select * from tblA order by birth;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                       |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | NULL          | idx_ageBirth | 9       | NULL |    3 |   100.00 | Using index; Using filesort |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from tblA where birth > '2018-01-01 00:00:00' order by birth;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | idx_ageBirth  | idx_ageBirth | 9       | NULL |    3 |    33.33 | Using where; Using index; Using filesort |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from tblA where birth > '2018-01-01 00:00:00' order by age;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | idx_ageBirth  | idx_ageBirth | 9       | NULL |    3 |    33.33 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from tblA where birth > '2018-01-01 00:00:00' order by age ASC, birth DESC;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+
|  1 | SIMPLE      | tblA  | NULL       | index | idx_ageBirth  | idx_ageBirth | 9       | NULL |    3 |    33.33 | Using where; Using index; Using filesort |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+------------------------------------------+

- 结论
order by会有2种排序方式, index和filesort, index效率高
order by满足两种情况,会使用index方式排序: 
  - order by语句使用索引最左前列
  - 使用Where子句与order by子句条件列组合满足索引最左前列
尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀
如果不再索引列上, filesort有2种排序方法:
  - 单路排序 (4.1版本后）
  - 多路排序 (4.1版本之前)
提高order by的速度方法：
  - Order by时select *是一个大忌, 只查询需要的字段，这点非常重要。在这里的影响是:
    - 当Query的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT/BLOB类型时，会用改进后的算法--单路排序，否则用老算法--多路排序
    - 两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的的风险会更大一些，所以要提高sort_buffer_size。
  - 尝试提高sort_buffer_size
    不管哪种算法, 提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的
  - 尝试提高max_length_for_sort_data
    提高这个参数， 会增加用改进算法的概率. 但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率.
  - 为排序使用索引
    index on column a, b, c
    order by能使用索引最左前缀
      - order by a
      - order by a, b
      - order by a, b, c
      - order by a DESC, b DESC, c DESC
    如果WHERE使用索引的最左前缀定义为常量，则order by能使用索引
      - WHERE a= const ORDER BY b, c
      - WHERE a= const AND b = const ORDER BY c
      - WHERE a = const AND b > const ORDER BY b, c
    不能使用索引进行排序:
      - ORDER BY a ASC, b DESC, c DESC   /* 排序不一致 */
      - WHERE g = const ORDER BY b, c    /* 丢失a索引 */
      - WHERE a = const ORDER BY c       /* 丢失b索引 */
      - WHERE a = const ORDER BY a, d    /* d不是索引的一部分 */
      - WHERE a in (...) ORDER BY b,c    /* 对于排序来说, 多个相等条件也是范围查询 */

3. GROUP BY的优化方式和ORDER一致
  - group by实质是先排序后进行分组， 最找索引建的最佳左前缀
  - 当无法使用索引列，增大max_length_for_sort_data参数的设置+增加sort_buffer_size参数的设置
  - where高于having， 能些在shere限定的条件就不要去having限定了.



慢查询日志
- 是什么
（1）MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具
体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。
（2）具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为
10，意思是运行10秒以上的语句。
（3）由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能
收集超过5秒的sql，结合之前explain进行全面分析。

- 怎么用
默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。
当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。

（1） 开启设置
SQL 							语句描述备注
SHOW VARIABLES LIKE '%slow_query_log%'; 		查看慢查询日志是否开启默认情况下slow_query_log 的值为OFF，表示慢查询日志是禁用的
set global slow_query_log=1; 				开启慢查询日志
SHOW VARIABLES LIKE 'long_query_time%'; 		查看慢查询设定阈值单位秒
set long_query_time=1 					设定慢查询阈值单位秒
SHOW GLOBAL STATUS LIKE '%Slow_queries%';               查看系统有多少条慢SQL

（2） 如永久生效需要修改配置文件my.cnf 中[mysqld]下配置
[mysqld]
slow_query_log=1
slow_query_log_file=/var/lib/mysql/atguigu-slow.log
long_query_time=3
log_output=FILE

（3） 运行查询时间长的sql，打开慢查询日志查看

(4) 日志分析工具mysqldumpslow  (atguigu-slow.log = 日志文件路径， 通过SHOW VARIABLES LIKE '%slow_query_log%';获取)
得到返回记录集最多的10 个SQL
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log
得到访问次数最多的10 个SQL
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log
得到按照时间排序的前10 条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log
另外建议在使用这些命令时结合| 和more 使用，否则有可能出现爆屏情况
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more



批量插入数据脚本
-建表
CREATE TABLE dept(
id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,
dname VARCHAR(20) NOT NULL DEFAULT "",
loc VARCHAR(13) NOT NULL DEFAULT ""
) ENGINE=INNODB DEFAULT CHARSET=UTF8;

CREATE TABLE emp
(
  id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, 
  ename VARCHAR(20) NOT NULL DEFAULT "",
  job VARCHAR(9) NOT NULL DEFAULT "",
  mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,
  hiredate DATE NOT NULL,
  salary DECIMAL(7,2) NOT NULL,
  comm DECIMAL(7,2) NOT NULL,
  deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0
)ENGINE=INNODB DEFAULT CHARSET=UTF8;

- 开启 (set global log_bin_trust_function_creators=1;)
在执行创建函数之前，首先请保证log_bin_trust_function_creators 参数为1，即on 开启状态。否则会报错.
查询：show variables like 'log_bin_trust_function_creators';
设置：set global log_bin_trust_function_creators=1;
当然，如上设置只存在于当前操作，想要永久生效，需要写入到配置文件中：
在[mysqld]中加上log_bin_trust_function_creators=1

- 定义函数 
随机产生字符串 (如果要删除函数：drop function rand_num;)
DELIMITER $$
CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)
BEGIN
DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
DECLARE return_str VARCHAR(255) DEFAULT '';
DECLARE i INT DEFAULT 0;
WHILE i < n DO
SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
SET i = i + 1;
END WHILE;
RETURN return_str;
END $$

随机产生部门编号 (如果要删除函数：drop function rand_num;)
#用于随机产生多少到多少的编号
DELIMITER $$
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN
DECLARE i INT DEFAULT 0;
SET i = FLOOR(from_num +RAND()*(to_num -from_num+1)) ;
RETURN i;
END$$


- 创建存储过程
创建往emp 表中插入数据的存储过程
DELIMITER $$
CREATE PROCEDURE insert_emp( START INT , max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
#set autocommit =0 把autocommit 设置成0
SET autocommit = 0;
REPEAT
SET i = i + 1;
INSERT INTO emp (empno, ename ,job ,mgr,hiredate,salary,comm,deptno ) 
VALUES ((START+i) ,rand_string(6) ,'SALES',0001, CURDATE(), rand_num(30,50), rand_num(1,10000), rand_num(1,10000));
UNTIL i = max_num
END REPEAT;
COMMIT;
END$$

创建往dept 表中插入数据的存储过程
#执行存储过程，往dept 表添加随机数据
DELIMITER $$
CREATE PROCEDURE `insert_dept`( max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0;
REPEAT
SET i = i + 1;
INSERT INTO dept ( deptno, dname,loc) VALUES (rand_num(1,10000),rand_string(8),rand_string(10));
UNTIL i = max_num
END REPEAT;
COMMIT;
END$$

- 调用存储过程
添加数据到部门表
#执行存储过程，往dept 表添加1 万条数据
DELIMITER ;
CALL insert_dept(10000);

添加数据到员工表
#执行存储过程，往emp 表添加50 万条数据
DELIMITER ;
CALL insert_emp(100000,500000);

- 批量删除某个表上的所有索引
删除索引的存储过程
DELIMITER $$
CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))
BEGIN
DECLARE done INT DEFAULT 0;
DECLARE ct INT DEFAULT 0;
DECLARE _index VARCHAR(200) DEFAULT '';
DECLARE _cur CURSOR FOR SELECT index_name FROM information_schema.STATISTICS WHERE
table_schema=dbname AND table_name=tablename AND seq_in_index=1 AND index_name <>'PRIMARY' ;
DECLARE CONTINUE HANDLER FOR NOT FOUND set done=2 ;
OPEN _cur;
FETCH _cur INTO _index;
WHILE _index<>'' DO
SET @str = CONCAT("drop index ",_index," on ",tablename );
PREPARE sql_str FROM @str ;
EXECUTE sql_str;
DEALLOCATE PREPARE sql_str;
SET _index='';
FETCH _cur INTO _index;
END WHILE;
CLOSE _cur;
END$$

执行存储过程
调用：CALL proc_drop_index("dbname","tablename");



SHOW PROFILE
-开启profile
查看profile 是否开启：show variables like '%profiling%';
如果没有开启，可以执行set profiling=1; 开启！

- 使用
show profiles



表锁 行所 页锁
create table mylock(
id int not null primary key auto_increment,
name varchar(20)
)engine myisam;

insert into mylock(name) values('a');
insert into mylock(name) values('b');
insert into mylock(name) values('c');
insert into mylock(name) values('d');
insert into mylock(name) values('e');

手动增加表锁
lock table 表名字 read(write), 表名字2 read(write), 其他;
查看表上加过的锁

查看哪些表被锁住
mysql> show open tables;
+--------------------+---------------------------+--------+-------------+
| Database           | Table                     | In_use | Name_locked |
+--------------------+---------------------------+--------+-------------+
| mysql              | routines                  |      0 |           0 |
| mysql              | parameter_type_elements   |      0 |           0 |
| performance_schema | global_status             |      0 |           0 |
| performance_schema | session_variables         |      0 |           0 |
| mydb01             | tblA                      |      0 |           0 |
| mysql              | help_keyword              |      0 |           0 |
| mysql              | help_category             |      0 |           0 |
| mysql              | help_topic                |      0 |           0 |

解锁
unlock tables;

调用lock table A read的session只能读A表，不能改A表，也不能读或改其他的表
某个session如果要读被其他session 添加了lock table ... read的表，那么可以读， 但是如果要改，那么SQL会阻塞，直到A上的read lock被解除

调用lock table A write的session可以读页可以改表A，但是不能读或改其他的表
某个session如果要读或改被其他session 添加了lock table ... write的表，那么SQL会阻塞，直到A上的read lock被解除.

MyISAM在执行查询语句(SELECT)前，会自动给涉及的所有表加读锁，在执行增删改操作前，给自动给涉及的表加写锁

锁类型		可否兼容		读锁		写锁
读锁		是		是		否
写锁		是		否		否

结论:
对MyISAM表进行操作， 会有以下情况:
1. 对MyISAM表的读操作(加读锁), 不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求，只有当读锁释放后，才会执行其他进程的写操作。
2. 对MyISAM表的写操作(加写锁), 会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作.

<****简而言之, 就是读锁会阻塞写，但是不会阻塞读，而写锁则会把读和写都阻塞****>

如何分析表锁定
可以通过检查table_locks_waited和table_locks_immediate状态变量分析系统上的表锁定:
SQL: show status like 'table%'

mysql> show status like 'table%';
+----------------------------+--------+
| Variable_name              | Value  |
+----------------------------+--------+
| Table_locks_immediate      | 21     |
| Table_locks_waited         | 0      |
| Table_open_cache_hits      | 510731 |
| Table_open_cache_misses    | 44     |
| Table_open_cache_overflows | 0      |
+----------------------------+--------+

这里有两个状态变量记录MySQL内部表级锁定的情况, 两个变量说明如下:
Table_locks_immediate: 产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1
Table_locks_waited： 出现表级锁定争用而发生等待的次数(不能立即获取锁的次数, 每等待一次锁值加1), 此值高则说明存在着较严重的标记锁征用情况.

此外， Myisam的读写锁是写优先， 这也是Myisam不适合左写为主表的引擎，因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞.


=================================================================================================================
InnoDB存储引擎, 开销大， 加锁慢, 会出现死锁， 锁定力度最小， 发生锁冲突的概率最低，并发度也最高.
InnoDB与MyISAM的最大不同有两点: 一是支持事务(Transaction)， 二是采用了行级锁

事务时由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称事务的ACID属性.
-原子性(Atomicity):事务时一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行.
-一致性(Consistent):在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性.事务结束时，所有的内部数据结构(如B数索引或双向链表)也都必须时正确的。

-隔离性(Isolation)：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。这意味着事务处理过程中的中间状态
对外部是不可见的，反之亦然.
-持久性(Durable): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持.

并发事务带来的问题:
更新丢失
当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不直到其他事务的存在，就会发生丢失更新问题--最后的更新覆盖了由其他事务所作的更新.

脏读
一个事务正在对一条记录做修改，在这个事务完成并提交前，这个记录的数据就处于不一致状态，这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些"脏"数据
并据此做进一步的处理，就会产生未提交的数据因爱关系。这种现象被形象的叫做"脏读".
比如，事务A读取到了事务B已修改但尚未提交的数据，还在这个数据基础上做了操作，此时，如果B事务回滚，A读取的数据无效，不符合一致性要求.

不可重复读
一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变，或某些记录已经被删除了，这种现象就叫做"不可重复读".
比如,事务A读取到了事务B已经提交的要修改或删除的数据，不符合隔离性.

幻读
一个事务按照相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为"幻读".
比如,事务A读取到了事务B提交的新增数据，不符合隔离性.
幻读和脏读有点类似.


更新丢失，脏读，不可重复读，和幻读，其实i都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决.

事务的隔离级别

读数据一致性及允许的并发副作用		读数据一致性				脏读	不可重复读	幻读
隔离级别
未提交读(read uncommitted)		最低级别，只能保证不读取梳理上损坏的数据	是	是		是
已提交读(read committed)			语句级					否	是		是
可重复读(repeatable read)		事务级					否	否		是
可序列化(Serializable)			最高级别，事务级				否	否		否

查看当前数据库的事务隔离级别: show variables like 'tx_isolation';


===========================================================================================================================================================
行锁
-建表
create table test_innodb_lock(a int(11),b varchar(16))engine=innodb;

insert into test_innodb_lock values(1,'b2');
insert into test_innodb_lock values(3,'3');
insert into test_innodb_lock values(4,'4000');
insert into test_innodb_lock values(5,'5000');
insert into test_innodb_lock values(6,'6000');
insert into test_innodb_lock values(7,'7000');
insert into test_innodb_lock values(8,'8000');
insert into test_innodb_lock values(9,'9000');
insert into test_innodb_lock values(1,'b1');

create index test_innodb_a_ind on test_innodb_lock(a);
create index test_innodb_lock_b_ind on test_innodb_lock(b);
select * from test_innodb_lock;

- 关闭自动提交
set autocommit=0;

- 演示
session 1:                                                              session 2:
mysql> set autocommit=0;                                                mysql> set autocommit=0;              
Query OK, 0 rows affected (0.00 sec)                                    Query OK, 0 rows affected (0.00 sec)  
                                      
mysql> select * from test_innodb_lock;                                  mysql> select * from test_innodb_lock;
+------+------+                                                         +------+------+                       
| a    | b    |                                                         | a    | b    |                       
+------+------+                                                         +------+------+                       
|    1 | b2   |                                                         |    1 | b2   |                       
|    3 | 3    |                                                         |    3 | 3    |                       
|    4 | 4000 |                                                         |    4 | 4000 |                       
|    5 | 5000 |                                                         |    5 | 5000 |                       
|    6 | 6000 |                                                         |    6 | 6000 |                       
|    7 | 7000 |                                                         |    7 | 7000 |                       
|    8 | 8000 |                                                         |    8 | 8000 |                       
|    9 | 9000 |                                                         |    9 | 9000 |                       
|    1 | b1   |                                                         |    1 | b1   |                       
+------+------+                                                         +------+------+                       
9 rows in set (0.00 sec)                                                9 rows in set (0.00 sec)              

mysql> update test_innodb_lock set b='4001' where a=4;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from test_innodb_lock;                                  mysql> select * from test_innodb_lock;     
+------+------+                                                         +------+------+                       
| a    | b    |                                                         | a    | b    |                       
+------+------+                                                         +------+------+                       
|    1 | b2   |                                                         |    1 | b2   |                       
|    3 | 3    |                                                         |    3 | 3    |                       
|    4 | 4001 |                                                         |    4 | 4000 |          ===========>因为mysql的默认隔离级别是可重复读，所以这里依然读到的是4000                      
|    5 | 5000 |                                                         |    5 | 5000 |                       
|    6 | 6000 |                                                         |    6 | 6000 |                       
|    7 | 7000 |                                                         |    7 | 7000 |                       
|    8 | 8000 |                                                         |    8 | 8000 |                       
|    9 | 9000 |                                                         |    9 | 9000 |                       
|    1 | b1   |                                                         |    1 | b1   |                       
+------+------+                                                         +------+------+                       
9 rows in set (0.01 sec)                                                9 rows in set (0.00 sec)              
                                      
mysql> commit;                                                          mysql> commit;          ====================>commit之后，就可以读到其他session更新过的值了              
Query OK, 0 rows affected (0.01 sec)                                    Query OK, 0 rows affected (0.00 sec)  
                                      
                                                                        mysql> select * from test_innodb_lock;
                                                                        +------+------+                       
                                                                        | a    | b    |                       
                                                                        +------+------+                       
                                                                        |    1 | b2   |                       
                                                                        |    3 | 3    |                       
                                                                        |    4 | 4001 |                       
                                                                        |    5 | 5000 |                       
                                                                        |    6 | 6000 |                       
                                                                        |    7 | 7000 |                       
                                                                        |    8 | 8000 |                       
                                                                        |    9 | 9000 |                       
                                                                        |    1 | b1   |                       
                                                                        +------+------+                       
                                                                        9 rows in set (0.00 sec)    



场景2：
session 1:                                                                      session 2:
mysql> update test_innodb_lock set b='5001' where a=5;                          mysql> update test_innodb_lock set b='5002' where a=5;                       
Query OK, 1 row affected (0.00 sec)                                             Query OK, 1 row affected (8.86 sec)                                          
Rows matched: 1  Changed: 1  Warnings: 0                                        Rows matched: 1  Changed: 1  Warnings: 0                                     
                                                                                                                                                             
mysql> commit;                                                                  mysql> select * from  test_innodb_lock where a = 5;       =====>    如果是更改同session1相同的一条记录，在session1先提交的更改commit前，session2的更改一直阻塞，直到session1执行commit          
Query OK, 0 rows affected (0.01 sec)                                            +------+------+                                                     如果是更改不同的记录，则没有影响，直接执行.         
                                                                                | a    | b    |                                                              
mysql> select * from  test_innodb_lock where a = 5;                             +------+------+                                                              
+------+------+                                                                 |    5 | 5002 |                                                              
| a    | b    |                                                                 +------+------+                                                              
+------+------+                                                                 1 row in set (0.01 sec)                                                      
|    5 | 5001 |                                                                                                                                              
+------+------+                                                                 mysql> commit;                                                               
1 row in set (0.00 sec)                                                         Query OK, 0 rows affected (0.01 sec)                                         
                                                                                                                                                             
mysql> commit;            =============> 由于mysql的可重复读隔离级别，只有再次commit,才能读到session2的更改                                                                                                                     
Query OK, 0 rows affected (0.00 sec)                                                                                                                         
                                                                                                                                                             
mysql> select * from  test_innodb_lock where a = 5;                                                                                                          
+------+------+                                                                                                                                              
| a    | b    |                                                                                                                                              
+------+------+                                                                                                                                              
|    5 | 5002 |                                                                                                                                              
+------+------+                                                                                                                                              
1 row in set (0.00 sec)                                                                                                                                      
          

行锁变表锁 (危险)

update test_innodb_lock set a=5 where b=5001; 

这里b字段定义是varchar，但是SQL里面b=5001没有加引号，产生了类型转换，使得索引失效。最终的结果是行锁变表锁，在其commit之前，其他session无法对表进行任何修改. 


什么是间隙锁
当我们用范围条件而不是姓党条件检索数据，并请求共享或排他锁时， InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内
但并不存在的记录，叫做"间隙".
InnoDB也会对这个"间隙"加锁,这种锁机制就是间隙锁.

间隙锁危害:
因为Query执行过程中通过范围查找的话, 他会锁定整个范围内所有的索引键值， 即使这个键值并不存在.
间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候
无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害.

如何锁定一行
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test_innodb_lock where b='5001' for update;
Empty set (0.00 sec)

mysql> update test_innodb_lock set b='5002' where b='5001';
Query OK, 0 rows affected (0.01 sec)
Rows matched: 0  Changed: 0  Warnings: 0

mysql> commit;
Query OK, 0 rows affected (0.00 sec)

在 SELECT UPDATE 和 COMMIT之间，其他session更改SELECT UPDATE锁住的那一行记录话，会被阻塞，直到commit之后才会执行.

如何分析行锁定
通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况
mysql> show status like 'innodb_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0     |
| Innodb_row_lock_time          | 13769 |
| Innodb_row_lock_time_avg      | 6884  |
| Innodb_row_lock_time_max      | 8854  |
| Innodb_row_lock_waits         | 2     |
+-------------------------------+-------+

对各个状态量的说明如下:
Innodb_row_lock_current_waits: 当前正在等待锁定的数量;
Innodb_row_lock_time: 从系统启动到现在锁定总时间长度;
Innodb_row_lock_time_avg:每次等待所花平均时间;
Innodb_row_lock_time_max: 从系统启动到现在等待最长的一次所化的时间;
Innodb_row_lock_waits: 系统启动后到现在总共等待的次数;

对着5个状态变量，比较重要的是:
 Innodb_row_lock_time_avg (等待平均时长)
 Innodb_row_lock_waits (等待总次数)
 Innodb_row_lock_time (等待总时长) 
尤其是当等待次数很高， 而且每次等待时长也不小的时候， 我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果来进行优化.


优化建议:
尽可能让所有数据检索都通过索引来完成，避免无效索引行锁升级为表锁.
合理涉及索引，精良缩小锁的范围
尽可能较少检索条件，避免间隙锁
精良控制事务大小，减少锁定资源量和时间长度
尽可能低级别事务隔离






















































































































































































































































