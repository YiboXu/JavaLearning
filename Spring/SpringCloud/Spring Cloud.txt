https://www.bilibili.com/video/av77706030/
https://www.bilibili.com/video/av32637612?p=4
https://www.bilibili.com/video/av77670328/
https://www.bilibili.com/video/av78638752?p=1

Dubbo和Spring cloud之间的区别
- Dubbo用的是RPC来进行各个微服务之间的通信， 而Spring cloud是通过Restful API来进行为负值之间的通信

微服务
强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，侠义的看，可以看作Eclipse里面的一个个微服务工程或者Module

微服务架构
将整个应用的业务逻辑分为一个个的微服务，每个微服务都运行在自己独立的进程中，轻量级,可以独立部署，并且还可以使用独立的数据库.

微服务优点:
每个服务足够内聚，足够小， 代码容易理解这样聚合一个指定的业务功能或业务需求
开发简单，效率高，一个服务可能就是专一的只干一件事.
微服务能够被小团队独立开发，这个小团队是2到5人的卡法人员组成。
微服务是松耦合的，是由功能意义的服务，无卵是在开发阶段或部署阶段都是独立的。
微服务能使用不同的语言开发
易于和地方放i成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, Hudson, bamboo.
微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。
微服务允许你利用融合最新技术。
微服务只是业务逻辑的代码，不会和HTML,CSS或其他界面组件混合。
每个微服务都有自己的的存储能力，可以由自己的数据库，也可以由统一数据库.

微服务缺点
开发人员要处理分布式系统的复杂性
多服务运维难度，随着服务的增加，运维的压力也在增大
系统部署依赖
服务间通信成本
数据一致性
系统继承测试
性能监控

微服务技术栈: 多种技术的集合体
一个分布式的微服务架构包括:
- 服务治理 (Dubbo)
- 服务注册 (Zookeeper)
- 服务调用 (Dubbo)
- 服务负载均衡 (nginx)
- 服务监控  (自己写的)
- ........
SpringCloud就上将上面这些组件统一起来，不需要再去分别为每个组件单独寻找各自使用的产品.

eureka服务注册中心Module
1. 引入cloud的一个新技术组件
  1.1 新增一个相关的maven坐标
  1.2 在主启动类上面标注@EnableEurekaServer
  1.3 java业务逻辑编码



传统的ACID分别是:
A (Atomicity) 原子性
C (Consistency) 一致性
I (Isolation) 独立性
D (Durability) 持久性

CAP:
C (Consistency) 一致性
A (Availability) 可用性
P (Partition tolerance) 分区容错性

zookeeper满足 CP， leader节点down掉后，会重新进行选举，一般持续30秒到2分钟，这个期间，服务不可用。但是zookeeper保证在任意时刻，俄格节点的数据是一致的.
Eureka满足AP. 满足任意时刻，服务可用，但是不保证每个节点数据一致.


网络摘抄理解：
一致性：读操作总是能读取到之前完成的写操作结果，满足这个条件的系统称为强一致系统，这里的“之前”一般对同一个客户端而言；
可用性：读写操作在单台机器发生故障的情况下仍然能够正常执行，而不需要等待发生故障的机器重启或者其上的服务迁移到其他机器；
分区可容忍性：机器故障、网络故障、机房停电等异常情况下仍然能够满足一致性和可用性。

自己的理解：
一致性：
如下图1中所示，Client A负责更新数据，为了保证Server 1和Server 2上的数据是一致的，Client A会将X=1的写操作同时发给Server 1和Server 2，但是当Client A和Server 2之间发生网络分区（网络无法连接）时，此时如果让write X=1的写操作在Server 1上成功，那Client B和Client C将从Server 1和Server 2上读取到不一致的X值；此时如果要保持X值的一致性，那么write X=1的写操作在Server 1和Server 2上都必须失败，这就是著名的CAP理论：在容忍网络分区的前提下，要么牺牲数据的一致性，要么牺牲写操作的可用性。
这里写图片描述
解决这个问题你可能会想到让Client C同时读取Server 1和Server 2上的X值和版本信息，然后取Server 1和Server 2最新版本的X值, 如下图2所示。但Client C和Server 1之间也可能发生网络分区，这本质上是牺牲读可用性换取写可用性，并没有突破CAP理论。
这里写图片描述

可用性：读写操作在单台服务器出问题后，在其他服务器上依然能够完成读写操作
重点在于：某个读写操作在出问题的机器上不能读写了，但是在其他机器可以完成

分区容错性：单台服务器，或多台服务器出问题（主要是网络问题）后，正常服务的服务器依然能正常提供服务，并且满足设计好的一致性和可用性
重点在于：部分服务器因网络问题，业务依然能够继续运行


Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端  负载均衡的工具.

简单的说，Ribbon是Netflix发步的开源项目，主要功能是提供客户端的软件负载均衡算法, 将Netflix的中间层服务连接在一起。
Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等.简单的说，就是在配置文件中列出Load Balancer (简称LB)后面所有的机器,
Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等)去连接这些及其.我们也很容易使用Ribbon实现自定义的负载均衡算法.

LB, 即负载均衡，在微服务或分布式集群中经常用的一种应用。
负载均衡简单的说就是将用户的请求平摊的分配到多个服务商，从而达到系统的HA.
常见的负载均衡有软件Nginx, LVS, 硬件F5等.
相应的在中间件，例如, dubbo和SpringCloud中均给我们提供了负载均衡，SpringCloud的负载均衡算法可以自定义.

集中式LB(偏硬件)
即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5，也可以是软件，如nginx)， 由该设施负责把访问请求通过某种策略转发至
服务的提供方；

进程内LB(偏软件)
将LB逻辑继承到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器.
Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址.

RoundRobinRule 轮询
RandomRule 随机
AvailabilityFilteringRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务， 
			  还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询车略进行访问

WeightedResponseTimeRule 根据平均响应事件计算所有服务的权重，响应事件越快服务权重越大被选中的概率越高。
                         刚启动时如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够了，会切换到WeightedResponseTimeRule

RetryRule                会按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务

BestAvailableRule        会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务

ZoneAvoidanceRule        默认规则， 符合判断server所在区域的性能和server的可用性选择器




























































